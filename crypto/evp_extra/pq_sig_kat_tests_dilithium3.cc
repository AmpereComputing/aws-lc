// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

#include <gtest/gtest.h>
#include <openssl/evp.h>
#include <vector>
#include "../fipsmodule/evp/internal.h"
#include "../dilithium/sig_dilithium.h"
#include "../test/file_test.h"
#include "../test/test_util.h"
#include "../rand_extra/pq_custom_randombytes.h"
#include "./internal.h"

 static void RunTest(FileTest *t)
{
  std::string count, mlen, smlen;
  std::vector<uint8_t> seed, msg, pk, sk, sm;

  ASSERT_TRUE(t->GetAttribute(&count, "count"));
  ASSERT_TRUE(t->GetBytes(&seed, "seed"));
  ASSERT_TRUE(t->GetAttribute(&mlen, "mlen"));
  ASSERT_TRUE(t->GetBytes(&msg, "msg"));
  ASSERT_TRUE(t->GetBytes(&pk, "pk"));
  ASSERT_TRUE(t->GetBytes(&sk, "sk"));
  ASSERT_TRUE(t->GetAttribute(&smlen, "smlen"));
  ASSERT_TRUE(t->GetBytes(&sm, "sm"));

  //the KAT files generated by the dilithium team use the optional APIs that
  //create a signature for a message m and append the message to the end of the
  //signature. We only want to bring the APIs that create and verify just the
  //signature, therefore each signature is a constant DILITHIUM3_SIGNATURE_BYTES
  //and we truncate the signed message down to a constant DILITHIUM3_SIGNATURE_BYTES.
  uint8_t signature[DILITHIUM3_SIGNATURE_BYTES];
  size_t signature_len = DILITHIUM3_SIGNATURE_BYTES;
  sm.resize(signature_len);

  //convert string read from KAT to int
  size_t mlen_int = std::stoi(mlen);

  //here we fix the DRBG (AES-CTR) so that we are able to seed it with the seed
  //from the KAT (testing only)
  pq_custom_randombytes_use_deterministic_for_testing();
  pq_custom_randombytes_init_for_testing(seed.data());

  //generate our dilithium public and private key pair
  EVP_PKEY_CTX *dilithium_pkey_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_DILITHIUM3, nullptr);
  ASSERT_NE(dilithium_pkey_ctx, nullptr);

  EVP_PKEY *dilithium_pkey = EVP_PKEY_new();
  ASSERT_NE(dilithium_pkey, nullptr);

  EXPECT_TRUE(EVP_PKEY_keygen_init(dilithium_pkey_ctx));
  EXPECT_TRUE(EVP_PKEY_keygen(dilithium_pkey_ctx, &dilithium_pkey));
  const DILITHIUM3_KEY *dilithium3Key = (DILITHIUM3_KEY *)(dilithium_pkey->pkey.ptr);
  EXPECT_EQ(Bytes(pk), Bytes(dilithium3Key->pub, DILITHIUM3_PUBLIC_KEY_BYTES));
  EXPECT_EQ(Bytes(sk), Bytes(dilithium3Key->priv, DILITHIUM3_PRIVATE_KEY_BYTES));

  //generate a signature for the message
  bssl::ScopedEVP_MD_CTX md_ctx;
  //we have to use EVP_DigestSign because dilithium supports the use of non-hash-then-sign
  //(just like ed25519) so we first init EVP_DigestSign WITHOUT a hash function.
  ASSERT_TRUE(EVP_DigestSignInit(md_ctx.get(), NULL, NULL, NULL, dilithium_pkey));
  ASSERT_TRUE(EVP_DigestSign(md_ctx.get(), signature, &signature_len, msg.data(), mlen_int));
  EXPECT_EQ(Bytes(sm), Bytes(signature, signature_len));

  //verify the signature for the message
  ASSERT_TRUE(EVP_DigestVerify(md_ctx.get(), signature, signature_len, msg.data(), mlen_int));

  EVP_PKEY_free(dilithium_pkey);
  EVP_PKEY_CTX_free(dilithium_pkey_ctx);
  md_ctx.Reset();
}

TEST(Dilithium3Test, KAT) {
  FileTestGTest("crypto/evp_extra/pq_sig_kat_tests_dilithium3.txt", RunTest);
}

