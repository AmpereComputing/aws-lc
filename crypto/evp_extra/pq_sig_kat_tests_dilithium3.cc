// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

#include <gtest/gtest.h>
#include <openssl/evp.h>
#include <openssl/randombytes.h>
#include <vector>
#include "../fipsmodule/evp/internal.h"
#include "../dilithium/sig_dilithium.h"
#include "../test/file_test.h"
#include "../test/test_util.h"
#include "./internal.h"

 static void RunTest(FileTest *t)
{
  std::string count, mlen, smlen;
  std::vector<uint8_t> seed, msg, pk, sk, sm;

  ASSERT_TRUE(t->GetAttribute(&count, "count"));
  ASSERT_TRUE(t->GetBytes(&seed, "seed"));
  ASSERT_TRUE(t->GetAttribute(&mlen, "mlen"));
  ASSERT_TRUE(t->GetBytes(&msg, "msg"));
  ASSERT_TRUE(t->GetBytes(&pk, "pk"));
  ASSERT_TRUE(t->GetBytes(&sk, "sk"));
  ASSERT_TRUE(t->GetAttribute(&smlen, "smlen"));
  ASSERT_TRUE(t->GetBytes(&sm, "sm"));

  //the KAT files generated by the dilithium team use the optional APIs that create a 
  //signature for a message m and append the message to the end of the signature. 
  //We only want to bring the APIs that create and verify just the signature,
  //therefore each signature is a constant DILITHIUM3_SIGNATURE_BYTES and we truncate
  //the signed message down to a constant DILITHIUM3_SIGNATURE_BYTES.
  uint8_t signature[DILITHIUM3_SIGNATURE_BYTES];
  size_t signature_len = DILITHIUM3_SIGNATURE_BYTES;
  sm.resize(signature_len);

  //convert string read from KAT to int (is there a cleaner way?)
  size_t mlen_int;
  std::stringstream sstream(mlen);
  sstream >> mlen_int;
 
  //here we fix the DRBG (AES-CTR) so that we are able to seed it with the seed from
  //the KAT (testing only)
  use_deterministic_randombytes_for_testing();
  randombytes_init_for_testing(seed.data());

  //generate our dilithium public and private key pair
  EVP_PKEY_CTX *dilithium_pkey_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_DILITHIUM3, nullptr);
  ASSERT_NE(dilithium_pkey_ctx, nullptr);

  EVP_PKEY *dilithium_pkey = EVP_PKEY_new();
  ASSERT_NE(dilithium_pkey, nullptr);

  EXPECT_TRUE(EVP_PKEY_keygen_init(dilithium_pkey_ctx));
  EXPECT_TRUE(EVP_PKEY_keygen(dilithium_pkey_ctx, &dilithium_pkey));
  const DILITHIUM3_KEY *dilithium3Key = (DILITHIUM3_KEY *)(dilithium_pkey->pkey.ptr);
  EXPECT_EQ(Bytes(pk), Bytes(dilithium3Key->pub, DILITHIUM3_PUBLIC_KEY_BYTES));
  EXPECT_EQ(Bytes(sk), Bytes(dilithium3Key->priv, DILITHIUM3_PRIVATE_KEY_BYTES));
   
  //generate a signature for the message
  EVP_MD_CTX *mdctx = NULL;
  mdctx = EVP_MD_CTX_new();
 
  //we have to use EVP_DigestSign because dilithium supports the use of non-hash-then-sign 
  //(just like ed25519) so we first init EVP_DigestSign WITHOUT a hash function.
  ASSERT_TRUE(EVP_DigestSignInit(mdctx, &dilithium_pkey_ctx, NULL, NULL, dilithium_pkey));
  ASSERT_TRUE(EVP_DigestSign(mdctx, signature, &signature_len, msg.data(), mlen_int));
  EXPECT_EQ(Bytes(sm), Bytes(signature, signature_len));

  //verify the signature for the message
  ASSERT_TRUE(EVP_DigestVerify(mdctx, signature, signature_len, msg.data(), mlen_int));
  
  EVP_PKEY_CTX_free(dilithium_pkey_ctx);
}

TEST(Dilithium3Test, KAT) {
  FileTestGTest("crypto/evp_extra/pq_sig_kat_tests_dilithium3.txt", RunTest);
}
