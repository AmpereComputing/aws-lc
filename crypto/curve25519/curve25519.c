/* Copyright (c) 2020, Google Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */

// Some of this code is taken from the ref10 version of Ed25519 in SUPERCOP
// 20141124 (http://bench.cr.yp.to/supercop.html). That code is released as
// public domain. Other parts have been replaced to call into code generated by
// Fiat (https://github.com/mit-plv/fiat-crypto) in //third_party/fiat.
//
// The field functions are shared by Ed25519 and X25519 where possible.

#include <openssl/curve25519.h>

#include <string.h>

#include <openssl/mem.h>
#include <openssl/rand.h>
#include <openssl/sha.h>

#include "internal.h"
#include "../internal.h"
#include "../fipsmodule/cpucap/internal.h"

#include "../../third_party/s2n-bignum/include/s2n-bignum_aws-lc.h"

// x25519_NEON is defined in asm/x25519-arm.S.
#if defined(OPENSSL_ARM) && !defined(OPENSSL_NO_ASM) && !defined(OPENSSL_APPLE)
#define BORINGSSL_X25519_NEON
#endif

#if (defined(OPENSSL_X86_64) || defined(OPENSSL_AARCH64)) && !defined(OPENSSL_NO_ASM)
#define CURVE25519_ASM_CAPABLE
#endif

void x25519_NEON(uint8_t out[32], const uint8_t scalar[32],
                 const uint8_t point[32]);


OPENSSL_INLINE int x25519_s2n_bignum_capable(void) {
#if defined(CURVE25519_ASM_CAPABLE)
  return 1;
#else
  return 0;
#endif
}

#if !defined(CURVE25519_ASM_CAPABLE)

void curve25519_x25519_byte(uint8_t res[static 32], uint8_t scalar[static 32], uint8_t point[static 32]) {
  abort();
}
void curve25519_x25519_byte_alt(uint8_t res[static 32], uint8_t scalar[static 32], uint8_t point[static 32]) {
  abort();
}

void curve25519_x25519base_byte(uint8_t res[static 32], uint8_t scalar[static 32]) {
  abort();
}
void curve25519_x25519base_byte_alt(uint8_t res[static 32], uint8_t scalar[static 32]) {
  abort();
}

#endif // !defined(CURVE25519_ASM_CAPABLE)

#if !defined(BORINGSSL_X25519_NEON)

void x25519_NEON(uint8_t out[32], const uint8_t scalar[32],
                 const uint8_t point[32]) {
  abort();
}

#endif // !defined(BORINGSSL_X25519_NEON)
// Below is the decision logic for which assembly backend implementation
// of x25519 we should use.
// Currently, we support the following implementations
//
// For x86:
//  - C: Native C-implementation
//  - s2n-bignum-no-alt: hardware implementation using bmi2+adx
//  - s2n-bignum-alt: hardware implementation using standard instructions
//
// For aarch64:
//  - C: Native C-implementation
//  - s2n-bignum-no-alt: hardware implementation for "small" multiplier throughput
//  - s2n-bignum-alt: hardware implementation for "higher" multiplier throughput
//
// For aarch32:
//  - neon: hardware implementation that works on Armv7
//
// If we figure out at run-time that we are not asm capable, we always fall back
// to the C-implementation.
//
// Performance numbers justifying the decision logic:
//
// TODO: put table here....
//

#define S2N_BIGNUM_USE_NO_ALT 1
#define S2N_BIGNUM_USE_ALT 2

OPENSSL_INLINE int x25519_s2n_bignum_alt_capable(void);
OPENSSL_INLINE int x25519_s2n_bignum_no_alt_capable(void);

OPENSSL_INLINE int x25519_s2n_bignum_alt_capable(void) {
#if defined(OPENSSL_X86_64)

  // If x25519 asm capable, the x86_64 alt s2n-bignum version should support
  // pretty much any x86_86 CPU.
  return 1;

#elif defined(OPENSSL_AARCH64)

  if (CRYPTO_is_ARMv8_wide_multiplier_capable() == 1) {
    return 1;
  } else {
    return 0;
  }

#else

  return 0;

#endif
}

OPENSSL_INLINE int x25519_s2n_bignum_no_alt_capable(void) {
#if defined(OPENSSL_X86_64)

  if (CRYPTO_is_BMI2_capable() == 1 && CRYPTO_is_ADX_capable() == 1) {
    return 1;
  } else {
    return 0;
  }

#elif defined(OPENSSL_AARCH64)

  // If x25519 asm capable, the Armv8 non-alt s2n-bignum version  should
  // support pretty much any Armv8 CPU.
  return 1;

#else

  return 0;

#endif
}

OPENSSL_INLINE int x25519_s2n_bignum() {

Do the unmanling thingy here...

#if defined(OPENSSL_X86_64)

  if (x25519_s2n_bignum_no_alt_capable() == 1) {
    return S2N_BIGNUM_USE_NO_ALT;
  } else if (x25519_s2n_bignum_alt_capable() == 1) {
    return S2N_BIGNUM_USE_ALT;
  } else {
    abort();
  }

#elif defined(OPENSSL_AARCH64)

  if (x25519_s2n_bignum_alt_capable() == 1) {
    return S2N_BIGNUM_USE_ALT;
  } else if (x25519_s2n_bignum_no_alt_capable() == 1) {
    return S2N_BIGNUM_USE_NO_ALT;
  } else {
    abort();
  }

#else 

  // Should not call this function except if s2n-bignum is support.
  abort();
}


OPENSSL_INLINE int x25519_s2n_bignum_private_key_something(...) {
  
}

// The neon implementation also works on 32-bit Arm ISAs.
OPENSSL_INLINE int x25519_Armv7_neon_capable(void) {
#if defined(BORINGSSL_X25519_NEON)
  return CRYPTO_is_NEON_capable();
#else
  return 0;
}

void x25519_hw(uint8_t out_shared_key[32], const uint8_t private_key[32],
           const uint8_t peer_public_value[32]) {

  uint8_t e[32];
  OPENSSL_memcpy(e, private_key, 32);
  e[0] &= 248;
  e[31] &= 127;
  e[31] |= 64;

  if ()
}


void ED25519_keypair_from_seed(uint8_t out_public_key[32],
                               uint8_t out_private_key[64],
                               const uint8_t seed[ED25519_SEED_LEN]) {
  uint8_t az[SHA512_DIGEST_LENGTH];
  SHA512(seed, ED25519_SEED_LEN, az);

  az[0] &= 248;
  az[31] &= 127;
  az[31] |= 64;

  ge_p3 A;
  x25519_ge_scalarmult_base(&A, az);
  ge_p3_tobytes(out_public_key, &A);

  OPENSSL_memcpy(out_private_key, seed, ED25519_SEED_LEN);
  OPENSSL_memcpy(out_private_key + ED25519_SEED_LEN, out_public_key, 32);
}

void ED25519_keypair(uint8_t out_public_key[32], uint8_t out_private_key[64]) {
  uint8_t seed[ED25519_SEED_LEN];
  RAND_bytes(seed, ED25519_SEED_LEN);
  ED25519_keypair_from_seed(out_public_key, out_private_key, seed);
  OPENSSL_cleanse(seed, ED25519_SEED_LEN);
}

int ED25519_sign(uint8_t out_sig[64], const uint8_t *message,
                 size_t message_len, const uint8_t private_key[64]) {
  // NOTE: The documentation on this function says that it returns zero on
  // allocation failure. While that can't happen with the current
  // implementation, we want to reserve the ability to allocate in this
  // implementation in the future.

  uint8_t az[SHA512_DIGEST_LENGTH];
  SHA512(private_key, 32, az);

  az[0] &= 248;
  az[31] &= 63;
  az[31] |= 64;

  SHA512_CTX hash_ctx;
  SHA512_Init(&hash_ctx);
  SHA512_Update(&hash_ctx, az + 32, 32);
  SHA512_Update(&hash_ctx, message, message_len);
  uint8_t nonce[SHA512_DIGEST_LENGTH];
  SHA512_Final(nonce, &hash_ctx);

  x25519_sc_reduce(nonce);
  ge_p3 R;
  x25519_ge_scalarmult_base(&R, nonce);
  ge_p3_tobytes(out_sig, &R);

  SHA512_Init(&hash_ctx);
  SHA512_Update(&hash_ctx, out_sig, 32);
  SHA512_Update(&hash_ctx, private_key + 32, 32);
  SHA512_Update(&hash_ctx, message, message_len);
  uint8_t hram[SHA512_DIGEST_LENGTH];
  SHA512_Final(hram, &hash_ctx);

  x25519_sc_reduce(hram);
  sc_muladd(out_sig + 32, hram, az, nonce);

  return 1;
}

int ED25519_verify(const uint8_t *message, size_t message_len,
                   const uint8_t signature[64], const uint8_t public_key[32]) {
  ge_p3 A;
  if ((signature[63] & 224) != 0 ||
      !x25519_ge_frombytes_vartime(&A, public_key)) {
    return 0;
  }

  fe_loose t;
  fe_neg(&t, &A.X);
  fe_carry(&A.X, &t);
  fe_neg(&t, &A.T);
  fe_carry(&A.T, &t);

  uint8_t pkcopy[32];
  OPENSSL_memcpy(pkcopy, public_key, 32);
  uint8_t rcopy[32];
  OPENSSL_memcpy(rcopy, signature, 32);
  uint8_t scopy[32];
  OPENSSL_memcpy(scopy, signature + 32, 32);

  // https://tools.ietf.org/html/rfc8032#section-5.1.7 requires that s be in
  // the range [0, order) in order to prevent signature malleability.

  // kOrder is the order of Curve25519 in little-endian form.
  static const uint64_t kOrder[4] = {
    UINT64_C(0x5812631a5cf5d3ed),
    UINT64_C(0x14def9dea2f79cd6),
    0,
    UINT64_C(0x1000000000000000),
  };
  for (size_t i = 3;; i--) {
    uint64_t word = CRYPTO_load_u64_le(scopy + i * 8);
    if (word > kOrder[i]) {
      return 0;
    } else if (word < kOrder[i]) {
      break;
    } else if (i == 0) {
      return 0;
    }
  }

  SHA512_CTX hash_ctx;
  SHA512_Init(&hash_ctx);
  SHA512_Update(&hash_ctx, signature, 32);
  SHA512_Update(&hash_ctx, public_key, 32);
  SHA512_Update(&hash_ctx, message, message_len);
  uint8_t h[SHA512_DIGEST_LENGTH];
  SHA512_Final(h, &hash_ctx);

  x25519_sc_reduce(h);

  ge_p2 R;
  ge_double_scalarmult_vartime(&R, h, &A, scopy);

  uint8_t rcheck[32];
  x25519_ge_tobytes(rcheck, &R);

  return CRYPTO_memcmp(rcheck, rcopy, sizeof(rcheck)) == 0;
}


void X25519_public_from_private(uint8_t out_public_value[32],
                                const uint8_t private_key[32]) {

  uint8_t e[32];
  OPENSSL_memcpy(e, private_key, 32);
  e[0] &= 248;
  e[31] &= 127;
  e[31] |= 64;

  if (x25519_s2n_bignum_capable()) {
    x25519_s2n_bignum_select();
  }
  else if (x25519_Armv7_neon_capable()) {
    static const uint8_t kMongomeryBasePoint[32] = {9};
    x25519_NEON(out_public_value, private_key, kMongomeryBasePoint);
  } else {
    X25519_public_from_private_nohw(out_public_value, e);
  }
}

void X25519_keypair(uint8_t out_public_value[32], uint8_t out_private_key[32]) {
  RAND_bytes(out_private_key, 32);

  // All X25519 implementations should decode scalars correctly (see
  // https://tools.ietf.org/html/rfc7748#section-5). However, if an
  // implementation doesn't then it might interoperate with random keys a
  // fraction of the time because they'll, randomly, happen to be correctly
  // formed.
  //
  // Thus we do the opposite of the masking here to make sure that our private
  // keys are never correctly masked and so, hopefully, any incorrect
  // implementations are deterministically broken.
  //
  // This does not affect security because, although we're throwing away
  // entropy, a valid implementation of scalarmult should throw away the exact
  // same bits anyway.
  out_private_key[0] |= ~248;
  out_private_key[31] &= ~64;
  out_private_key[31] |= ~127;

  X25519_public_from_private(out_public_value, out_private_key);
}

int X25519(uint8_t out_shared_key[32], const uint8_t private_key[32],
           const uint8_t peer_public_value[32]) {

  static const uint8_t kZeros[32] = {0};

  if (curve25519_asm_capable()) {
    x25519_NEON(out_shared_key, private_key, peer_public_value);
  } else {
    x25519_scalar_mult_generic_nohw(out_shared_key, private_key, peer_public_value);
  }

  // The all-zero output results when the input is a point of small order.
  // See https://www.rfc-editor.org/rfc/rfc7748#section-6.1.
  return CRYPTO_memcmp(kZeros, out_shared_key, 32) != 0;
}
