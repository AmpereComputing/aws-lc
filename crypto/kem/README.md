# AWS-LC KEM design

## Key Encapsulation Mechanism (KEM)

The purpose of a KEM is to establish a shared secret between two parties. There are three main functionalities defined for a KEM: key generation, encapsulation, decapsulation. The protocol works in three steps:

```
1. Alice generates her key pair (public_key, secret_key). Sends public_key to Bob.
2. Bob generates a shared secret and encapsulates it using Alices public key.
   This produces a ciphertext. Sends ciphertext to Alice.
3. Alice decapsulates the ciphertext with her key pair and obtains the shared secret.
   Alices and Bobs shared secrets are the same if the protocol succeeded.
```

The KEM design in AWS-LC is generic and not specific to any particular KEM. The primary use-case for the API are the post-quantum cryptographic algorithms that were specified and evaluated in NIST's Post-Quantum Crypto Standardization Project ([link](https://csrc.nist.gov/Projects/post-quantum-cryptography/post-quantum-cryptography-standardization)).

## The public KEM API

**Core functions.** To use a KEM, the customer needs to have access to three core functions: key generation, encapsulation, decapsulation. Following the general design in AWS-LC, these these three functions are offered in the form of standard AWS-LC EVP APIs:

```
// Generates a (public, private) key pair
EVP_PKEY_keygen(ctx, &pkey);

// KEM Encapsulation
EVP_PKEY_encapsulate(ctx, ciphertext, &ciphertext_len,
                          shared_secret, &shared_secret_len);

// KEM Decapsulation
EVP_PKEY_decapsulate(ctx, shared_secret, &shared_secret_len,
                          ciphertext, ciphertext_len);
```

The `ctx` variable above is a pointer to a “context” object of type `EVP_PKEY_CTX`. The `pkey` variable listed as an argument of `EVP_PKEY_keygen` function is a pointer to an object of type `EVP_PKEY`. The `ciphertext` and `shared_secret` are byte arrays of length `ciphertext_len` and `shared_secret_len`, respectively.

**The context.** The customer needs to create the context. Depending on the use case, this can be done in two ways:

```
1. EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_KEM, NULL);
   EVP_PKEY_CTX_kem_set_params(ctx, NID_KYBER512);
```

This creates a fresh context of type `EVP_PKEY_KEM` and sets the specific KEM parameters (Kyber512 in this example). The context is now ready for key generation (`EVP_PKEY_keygen`). However, the context created in this way doesn’t have an associated key (`EVP_PKEY`), so obviously, we can’t encapsulate/decapsulate with it. Therefore, this is useful for key generation only, i.e. before we have a key.

The second way to create a context is with an already existing key (`EVP_PKEY`):

```
2. EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new(pkey, NULL);
```

This creates a fresh context of type `EVP_PKEY_KEM`, sets the specific KEM parameters defined in the `pkey` object itself, and associates `pkey` to the context. The context is now ready to encapsulate/decapsulate because it contains the encapsulation/decapsulation key. The key is usually either generated by ourselves via `EVP_PKEY_keygen`, or we received the public key of the other party as a raw byte array and created the key as shown below.

**EVP_PKEY from/to raw data.** The customer sometimes needs to store/load the key-pair (`public_key, secret_key`) to/from memory. The customer certainly needs to be able to send/receive the `public_key` as part of the protocol. Therefore, we define the following methods:

```
1. Create EVP_PKEY object from raw data:

   EVP_PKEY *EVP_PKEY_kem_new_raw_key(int nid,
                                      const uint8_t *in_public, size_t len_public,
                                      const uint8_t *in_secret, size_t len_secret);                             
   EVP_PKEY *EVP_PKEY_kem_new_raw_public_key(int nid, const uint8_t *in, size_t len);
   EVP_PKEY *EVP_PKEY_kem_new_raw_secret_key(int nid, const uint8_t *in, size_t len);
```

and

```
2. Extract raw data from EVP_PKEY object:

   OPENSSL_EXPORT int EVP_PKEY_get_raw_private_key(const EVP_PKEY *pkey,
                                                   uint8_t *out, size_t *out_len);
   OPENSSL_EXPORT int EVP_PKEY_get_raw_public_key(const EVP_PKEY *pkey,
                                                  uint8_t *out, size_t *out_len);
```

**KEM parameters size.** The customer needs to know the size of they keys, the ciphertext, and the shared secret. All the sizes can be retrieved by calling the above listed APIs with `NULL` parameters in place of the actual output pointers. For example, calling:

```
EVP_PKEY_encapsulate(ctx, NULL, &ciphertext_len,
                          NULL, &shared_secret_len);
```

will store the size of the ciphertext and the shared secret (of the KEM specified in `ctx`) in `ciphertext_len` and `shared_secret_len`, respectively.

## Full example

Simulation of one KEM protocol execution using Kyber512:

```
                              ALICE                                  |                                      BOB
// START                              Alice and Bob have agreed which KEM to use (Kyber512 in this case)

// KEY GENERATION
// Create the contex.
EVP_PKEY_CTX *keygen_ctx;
keygen_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_KEM, NULL);
EVP_PKEY_CTX_kem_set_params(keygen_ctx, NID_KYBER512);

// Generate the key.
EVP_PKEY *key;
EVP_PKEY_keygen_init(keygen_ctx);
EVP_PKEY_keygen(keygen_ctx, key);

// Extract the raw public key.
uint8_t *pub_key;
size_t pub_key_len;

// Get the required buffer length and allocate the buffer.
EVP_PKEY_get_raw_public_key(key, NULL, &pub_key_len);
pub_key = OPENSSL_malloc(pub_key_len);

// Get the raw public key.
EVP_PKEY_get_raw_public_key(key, pub_key, &pub_key_len);
                                                                 pub_key
                                                           ------------------->       
                                                                                  // ENCAPSULATION
                                                                                  // Set the received raw public key.
                                                                                  EVP_PKEY *key;
                                                                                  key = EVP_PKEY_kem_new_raw_public_key(NID_KYBER512,
                                                                                                                        pub_key, pub_key_len);

                                                                                  // Create the context.
                                                                                  EVP_PKEY_CTX *encaps_ctx;
                                                                                  encaps_ctx = EVP_PKEY_CTX_new(key, NULL);

                                                                                  // Get the required buffer lengths and allocate the buffers.
                                                                                  uint8_t *ct, *ss;      // ciphertext and shared secret,
                                                                                  size_t ct_len, ss_len; // and their lengths.
                                                                                  EVP_PKEY_encapsulate(encaps_ctx, NULL, &ct_len, NULL, &ss_len);
                                                                                  ct = OPENSSL_malloc(ct_len);
                                                                                  ss = OPENSSL_malloc(ss_len);

                                                                                  // Encapsulate.
                                                                                  EVP_PKEY_encapsulate(encaps_ctx, ct, &ct_len, ss, &ss_len);
                                                                    ct                
                                                           <-------------------
// DECAPSULATION
// Create the context.
EVP_PKEY_CTX *decaps_ctx;
decaps_ctx = EVP_PKEY_CTX_new(key, NULL);

// Get the required buffer length and allocate the buffer.
uint8_t *ss;   // shared secret,
size_t ss_len; // and its length.

EVP_PKEY_decapsulate(decaps_ctx, NULL, &ss_len, ct, ct_len);
ss = OPENSSL_malloc(ss_len);

// Decapsulate.
EVP_PKEY_decapsulate(decaps_ctx, ss, &ss_len, ct, ct_len);

// END                          Alice's shared secret is equal to Bob's shared secret if the protocol succeeded.


```
Notes about the code snipet above:
* The functions used in the example can fail. For brevity, we omit the success/failure checks, but they should definitely be added to any code using the API.
* Memory allocated in several places in the example is not freed. The memory should definitely be freed in any production code to avoid memory leaks.

