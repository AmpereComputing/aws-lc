<!DOCTYPE html>
<html>
  <head>
    <title>AWS-LC - asn1.h</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="doc.css">
  </head>

  <body>
    <div id="main">
    <div class="title">
      <h2>asn1.h</h2>
      <a href="headers.html">All headers</a>
    </div>

    <p>Legacy ASN.1 library.</p><p>This header is part of OpenSSL&#39;s ASN.1 implementation. It is retained for compatibility but should not be used by new code. The functions are difficult to use correctly, and have buggy or non-standard behaviors. They are thus particularly prone to behavior changes and API removals, as BoringSSL iterates on these issues.</p><p>Use the new <tt>CBS</tt> and <tt>CBB</tt> library in &lt;openssl/bytestring.h&gt; instead.</p>

    <ol>
      
        
          <li class="header"><a href="#Tag-constants">Tag constants</a></li>
          
            <li><a href="#V_ASN1_UNIVERSAL"><tt>V_ASN1_UNIVERSAL</tt></a></li>
          
            <li><a href="#V_ASN1_APPLICATION"><tt>V_ASN1_APPLICATION</tt></a></li>
          
            <li><a href="#V_ASN1_CONTEXT_SPECIFIC"><tt>V_ASN1_CONTEXT_SPECIFIC</tt></a></li>
          
            <li><a href="#V_ASN1_PRIVATE"><tt>V_ASN1_PRIVATE</tt></a></li>
          
            <li><a href="#V_ASN1_CONSTRUCTED"><tt>V_ASN1_CONSTRUCTED</tt></a></li>
          
            <li><a href="#V_ASN1_PRIMITIVE_TAG"><tt>V_ASN1_PRIMITIVE_TAG</tt></a></li>
          
            <li><a href="#V_ASN1_MAX_UNIVERSAL"><tt>V_ASN1_MAX_UNIVERSAL</tt></a></li>
          
            <li><a href="#V_ASN1_UNDEF"><tt>V_ASN1_UNDEF</tt></a></li>
          
            <li><a href="#V_ASN1_OTHER"><tt>V_ASN1_OTHER</tt></a></li>
          
            <li><a href="#V_ASN1_ANY"><tt>V_ASN1_ANY</tt></a></li>
          
            <li><a href="#V_ASN1_EOC"><tt>V_ASN1_EOC</tt></a></li>
          
            <li><a href="#V_ASN1_BOOLEAN"><tt>V_ASN1_BOOLEAN</tt></a></li>
          
            <li><a href="#V_ASN1_INTEGER"><tt>V_ASN1_INTEGER</tt></a></li>
          
            <li><a href="#V_ASN1_BIT_STRING"><tt>V_ASN1_BIT_STRING</tt></a></li>
          
            <li><a href="#V_ASN1_OCTET_STRING"><tt>V_ASN1_OCTET_STRING</tt></a></li>
          
            <li><a href="#V_ASN1_NULL"><tt>V_ASN1_NULL</tt></a></li>
          
            <li><a href="#V_ASN1_OBJECT"><tt>V_ASN1_OBJECT</tt></a></li>
          
            <li><a href="#V_ASN1_OBJECT_DESCRIPTOR"><tt>V_ASN1_OBJECT_DESCRIPTOR</tt></a></li>
          
            <li><a href="#V_ASN1_EXTERNAL"><tt>V_ASN1_EXTERNAL</tt></a></li>
          
            <li><a href="#V_ASN1_REAL"><tt>V_ASN1_REAL</tt></a></li>
          
            <li><a href="#V_ASN1_ENUMERATED"><tt>V_ASN1_ENUMERATED</tt></a></li>
          
            <li><a href="#V_ASN1_UTF8STRING"><tt>V_ASN1_UTF8STRING</tt></a></li>
          
            <li><a href="#V_ASN1_SEQUENCE"><tt>V_ASN1_SEQUENCE</tt></a></li>
          
            <li><a href="#V_ASN1_SET"><tt>V_ASN1_SET</tt></a></li>
          
            <li><a href="#V_ASN1_NUMERICSTRING"><tt>V_ASN1_NUMERICSTRING</tt></a></li>
          
            <li><a href="#V_ASN1_PRINTABLESTRING"><tt>V_ASN1_PRINTABLESTRING</tt></a></li>
          
            <li><a href="#V_ASN1_T61STRING"><tt>V_ASN1_T61STRING</tt></a></li>
          
            <li><a href="#V_ASN1_TELETEXSTRING"><tt>V_ASN1_TELETEXSTRING</tt></a></li>
          
            <li><a href="#V_ASN1_VIDEOTEXSTRING"><tt>V_ASN1_VIDEOTEXSTRING</tt></a></li>
          
            <li><a href="#V_ASN1_IA5STRING"><tt>V_ASN1_IA5STRING</tt></a></li>
          
            <li><a href="#V_ASN1_UTCTIME"><tt>V_ASN1_UTCTIME</tt></a></li>
          
            <li><a href="#V_ASN1_GENERALIZEDTIME"><tt>V_ASN1_GENERALIZEDTIME</tt></a></li>
          
            <li><a href="#V_ASN1_GRAPHICSTRING"><tt>V_ASN1_GRAPHICSTRING</tt></a></li>
          
            <li><a href="#V_ASN1_ISO64STRING"><tt>V_ASN1_ISO64STRING</tt></a></li>
          
            <li><a href="#V_ASN1_VISIBLESTRING"><tt>V_ASN1_VISIBLESTRING</tt></a></li>
          
            <li><a href="#V_ASN1_GENERALSTRING"><tt>V_ASN1_GENERALSTRING</tt></a></li>
          
            <li><a href="#V_ASN1_UNIVERSALSTRING"><tt>V_ASN1_UNIVERSALSTRING</tt></a></li>
          
            <li><a href="#V_ASN1_BMPSTRING"><tt>V_ASN1_BMPSTRING</tt></a></li>
          
            <li><a href="#V_ASN1_NEG"><tt>V_ASN1_NEG</tt></a></li>
          
            <li><a href="#V_ASN1_NEG_INTEGER"><tt>V_ASN1_NEG_INTEGER</tt></a></li>
          
            <li><a href="#V_ASN1_NEG_ENUMERATED"><tt>V_ASN1_NEG_ENUMERATED</tt></a></li>
          
            <li><a href="#B_ASN1_NUMERICSTRING"><tt>B_ASN1_NUMERICSTRING</tt></a></li>
          
            <li><a href="#B_ASN1_PRINTABLESTRING"><tt>B_ASN1_PRINTABLESTRING</tt></a></li>
          
            <li><a href="#B_ASN1_T61STRING"><tt>B_ASN1_T61STRING</tt></a></li>
          
            <li><a href="#B_ASN1_TELETEXSTRING"><tt>B_ASN1_TELETEXSTRING</tt></a></li>
          
            <li><a href="#B_ASN1_VIDEOTEXSTRING"><tt>B_ASN1_VIDEOTEXSTRING</tt></a></li>
          
            <li><a href="#B_ASN1_IA5STRING"><tt>B_ASN1_IA5STRING</tt></a></li>
          
            <li><a href="#B_ASN1_GRAPHICSTRING"><tt>B_ASN1_GRAPHICSTRING</tt></a></li>
          
            <li><a href="#B_ASN1_ISO64STRING"><tt>B_ASN1_ISO64STRING</tt></a></li>
          
            <li><a href="#B_ASN1_VISIBLESTRING"><tt>B_ASN1_VISIBLESTRING</tt></a></li>
          
            <li><a href="#B_ASN1_GENERALSTRING"><tt>B_ASN1_GENERALSTRING</tt></a></li>
          
            <li><a href="#B_ASN1_UNIVERSALSTRING"><tt>B_ASN1_UNIVERSALSTRING</tt></a></li>
          
            <li><a href="#B_ASN1_OCTET_STRING"><tt>B_ASN1_OCTET_STRING</tt></a></li>
          
            <li><a href="#B_ASN1_BIT_STRING"><tt>B_ASN1_BIT_STRING</tt></a></li>
          
            <li><a href="#B_ASN1_BMPSTRING"><tt>B_ASN1_BMPSTRING</tt></a></li>
          
            <li><a href="#B_ASN1_UNKNOWN"><tt>B_ASN1_UNKNOWN</tt></a></li>
          
            <li><a href="#B_ASN1_UTF8STRING"><tt>B_ASN1_UTF8STRING</tt></a></li>
          
            <li><a href="#B_ASN1_UTCTIME"><tt>B_ASN1_UTCTIME</tt></a></li>
          
            <li><a href="#B_ASN1_GENERALIZEDTIME"><tt>B_ASN1_GENERALIZEDTIME</tt></a></li>
          
            <li><a href="#B_ASN1_SEQUENCE"><tt>B_ASN1_SEQUENCE</tt></a></li>
          
            <li><a href="#ASN1_tag2bit"><tt>ASN1_tag2bit</tt></a></li>
          
            <li><a href="#ASN1_tag2str"><tt>ASN1_tag2str</tt></a></li>
          
        
      
        
          <li class="header"><a href="#API-conventions">API conventions</a></li>
          
            
          
            <li><a href="#d2i_SAMPLE"><tt>d2i_SAMPLE</tt></a></li>
          
            <li><a href="#d2i_SAMPLE_with_reuse"><tt>d2i_SAMPLE_with_reuse</tt></a></li>
          
            <li><a href="#i2d_SAMPLE"><tt>i2d_SAMPLE</tt></a></li>
          
            <li><a href="#I2D_OF"><tt>I2D_OF</tt></a></li>
          
            <li><a href="#CHECKED_I2D_OF"><tt>CHECKED_I2D_OF</tt></a></li>
          
            
          
        
      
        
          <li class="header"><a href="#ASN.1-types">ASN.1 types</a></li>
          
            <li><a href="#DECLARE_ASN1_ITEM"><tt>DECLARE_ASN1_ITEM</tt></a></li>
          
            <li><a href="#ASN1_ITEM_rptr"><tt>ASN1_ITEM_rptr</tt></a></li>
          
            
          
            <li><a href="#ASN1_ITEM_ref"><tt>ASN1_ITEM_ref</tt></a></li>
          
            <li><a href="#ASN1_ITEM_ptr"><tt>ASN1_ITEM_ptr</tt></a></li>
          
            
          
            <li><a href="#ASN1_item_new"><tt>ASN1_item_new</tt></a></li>
          
            <li><a href="#ASN1_item_free"><tt>ASN1_item_free</tt></a></li>
          
            <li><a href="#ASN1_item_d2i"><tt>ASN1_item_d2i</tt></a></li>
          
            <li><a href="#ASN1_item_i2d"><tt>ASN1_item_i2d</tt></a></li>
          
            <li><a href="#ASN1_item_dup"><tt>ASN1_item_dup</tt></a></li>
          
            <li><a href="#ASN1_item_d2i_fp"><tt>ASN1_item_d2i_fp</tt></a></li>
          
            <li><a href="#ASN1_item_d2i_bio"><tt>ASN1_item_d2i_bio</tt></a></li>
          
            <li><a href="#ASN1_item_i2d_fp"><tt>ASN1_item_i2d_fp</tt></a></li>
          
            <li><a href="#ASN1_item_i2d_bio"><tt>ASN1_item_i2d_bio</tt></a></li>
          
            <li><a href="#ASN1_i2d_bio"><tt>ASN1_i2d_bio</tt></a></li>
          
            <li><a href="#ASN1_i2d_bio_of"><tt>ASN1_i2d_bio_of</tt></a></li>
          
            <li><a href="#ASN1_item_unpack"><tt>ASN1_item_unpack</tt></a></li>
          
            <li><a href="#ASN1_item_pack"><tt>ASN1_item_pack</tt></a></li>
          
        
      
        
          <li class="header"><a href="#Booleans">Booleans</a></li>
          
            <li><a href="#ASN1_BOOLEAN_FALSE"><tt>ASN1_BOOLEAN_FALSE</tt></a></li>
          
            <li><a href="#ASN1_BOOLEAN_TRUE"><tt>ASN1_BOOLEAN_TRUE</tt></a></li>
          
            <li><a href="#ASN1_BOOLEAN_NONE"><tt>ASN1_BOOLEAN_NONE</tt></a></li>
          
            <li><a href="#d2i_ASN1_BOOLEAN"><tt>d2i_ASN1_BOOLEAN</tt></a></li>
          
            <li><a href="#i2d_ASN1_BOOLEAN"><tt>i2d_ASN1_BOOLEAN</tt></a></li>
          
            
          
        
      
        
          <li class="header"><a href="#Strings">Strings</a></li>
          
            <li><a href="#asn1_string_st"><tt>asn1_string_st</tt></a></li>
          
            <li><a href="#ASN1_STRING_FLAG_BITS_LEFT"><tt>ASN1_STRING_FLAG_BITS_LEFT</tt></a></li>
          
            <li><a href="#ASN1_STRING_type_new"><tt>ASN1_STRING_type_new</tt></a></li>
          
            <li><a href="#ASN1_STRING_new"><tt>ASN1_STRING_new</tt></a></li>
          
            <li><a href="#ASN1_STRING_free"><tt>ASN1_STRING_free</tt></a></li>
          
            <li><a href="#ASN1_STRING_clear_free"><tt>ASN1_STRING_clear_free</tt></a></li>
          
            <li><a href="#ASN1_STRING_copy"><tt>ASN1_STRING_copy</tt></a></li>
          
            <li><a href="#ASN1_STRING_dup"><tt>ASN1_STRING_dup</tt></a></li>
          
            <li><a href="#ASN1_STRING_type"><tt>ASN1_STRING_type</tt></a></li>
          
            <li><a href="#ASN1_STRING_get0_data"><tt>ASN1_STRING_get0_data</tt></a></li>
          
            <li><a href="#ASN1_STRING_data"><tt>ASN1_STRING_data</tt></a></li>
          
            <li><a href="#ASN1_STRING_length"><tt>ASN1_STRING_length</tt></a></li>
          
            <li><a href="#ASN1_STRING_cmp"><tt>ASN1_STRING_cmp</tt></a></li>
          
            <li><a href="#ASN1_STRING_set"><tt>ASN1_STRING_set</tt></a></li>
          
            <li><a href="#ASN1_STRING_set0"><tt>ASN1_STRING_set0</tt></a></li>
          
            <li><a href="#ASN1_BMPSTRING_new"><tt>ASN1_BMPSTRING_new</tt></a></li>
          
            <li><a href="#ASN1_GENERALSTRING_new"><tt>ASN1_GENERALSTRING_new</tt></a></li>
          
            <li><a href="#ASN1_IA5STRING_new"><tt>ASN1_IA5STRING_new</tt></a></li>
          
            <li><a href="#ASN1_OCTET_STRING_new"><tt>ASN1_OCTET_STRING_new</tt></a></li>
          
            <li><a href="#ASN1_PRINTABLESTRING_new"><tt>ASN1_PRINTABLESTRING_new</tt></a></li>
          
            <li><a href="#ASN1_T61STRING_new"><tt>ASN1_T61STRING_new</tt></a></li>
          
            <li><a href="#ASN1_UNIVERSALSTRING_new"><tt>ASN1_UNIVERSALSTRING_new</tt></a></li>
          
            <li><a href="#ASN1_UTF8STRING_new"><tt>ASN1_UTF8STRING_new</tt></a></li>
          
            <li><a href="#ASN1_VISIBLESTRING_new"><tt>ASN1_VISIBLESTRING_new</tt></a></li>
          
            <li><a href="#ASN1_BMPSTRING_free"><tt>ASN1_BMPSTRING_free</tt></a></li>
          
            <li><a href="#ASN1_GENERALSTRING_free"><tt>ASN1_GENERALSTRING_free</tt></a></li>
          
            <li><a href="#ASN1_IA5STRING_free"><tt>ASN1_IA5STRING_free</tt></a></li>
          
            <li><a href="#ASN1_OCTET_STRING_free"><tt>ASN1_OCTET_STRING_free</tt></a></li>
          
            <li><a href="#ASN1_PRINTABLESTRING_free"><tt>ASN1_PRINTABLESTRING_free</tt></a></li>
          
            <li><a href="#ASN1_T61STRING_free"><tt>ASN1_T61STRING_free</tt></a></li>
          
            <li><a href="#ASN1_UNIVERSALSTRING_free"><tt>ASN1_UNIVERSALSTRING_free</tt></a></li>
          
            <li><a href="#ASN1_UTF8STRING_free"><tt>ASN1_UTF8STRING_free</tt></a></li>
          
            <li><a href="#ASN1_VISIBLESTRING_free"><tt>ASN1_VISIBLESTRING_free</tt></a></li>
          
            <li><a href="#d2i_ASN1_BMPSTRING"><tt>d2i_ASN1_BMPSTRING</tt></a></li>
          
            <li><a href="#d2i_ASN1_GENERALSTRING"><tt>d2i_ASN1_GENERALSTRING</tt></a></li>
          
            <li><a href="#d2i_ASN1_IA5STRING"><tt>d2i_ASN1_IA5STRING</tt></a></li>
          
            <li><a href="#d2i_ASN1_OCTET_STRING"><tt>d2i_ASN1_OCTET_STRING</tt></a></li>
          
            <li><a href="#d2i_ASN1_PRINTABLESTRING"><tt>d2i_ASN1_PRINTABLESTRING</tt></a></li>
          
            <li><a href="#d2i_ASN1_T61STRING"><tt>d2i_ASN1_T61STRING</tt></a></li>
          
            <li><a href="#d2i_ASN1_UNIVERSALSTRING"><tt>d2i_ASN1_UNIVERSALSTRING</tt></a></li>
          
            <li><a href="#d2i_ASN1_UTF8STRING"><tt>d2i_ASN1_UTF8STRING</tt></a></li>
          
            <li><a href="#d2i_ASN1_VISIBLESTRING"><tt>d2i_ASN1_VISIBLESTRING</tt></a></li>
          
            <li><a href="#i2d_ASN1_BMPSTRING"><tt>i2d_ASN1_BMPSTRING</tt></a></li>
          
            <li><a href="#i2d_ASN1_GENERALSTRING"><tt>i2d_ASN1_GENERALSTRING</tt></a></li>
          
            <li><a href="#i2d_ASN1_IA5STRING"><tt>i2d_ASN1_IA5STRING</tt></a></li>
          
            <li><a href="#i2d_ASN1_OCTET_STRING"><tt>i2d_ASN1_OCTET_STRING</tt></a></li>
          
            <li><a href="#i2d_ASN1_PRINTABLESTRING"><tt>i2d_ASN1_PRINTABLESTRING</tt></a></li>
          
            <li><a href="#i2d_ASN1_T61STRING"><tt>i2d_ASN1_T61STRING</tt></a></li>
          
            <li><a href="#i2d_ASN1_UNIVERSALSTRING"><tt>i2d_ASN1_UNIVERSALSTRING</tt></a></li>
          
            <li><a href="#i2d_ASN1_UTF8STRING"><tt>i2d_ASN1_UTF8STRING</tt></a></li>
          
            <li><a href="#i2d_ASN1_VISIBLESTRING"><tt>i2d_ASN1_VISIBLESTRING</tt></a></li>
          
            
          
            <li><a href="#ASN1_OCTET_STRING_dup"><tt>ASN1_OCTET_STRING_dup</tt></a></li>
          
            <li><a href="#ASN1_OCTET_STRING_cmp"><tt>ASN1_OCTET_STRING_cmp</tt></a></li>
          
            <li><a href="#ASN1_OCTET_STRING_set"><tt>ASN1_OCTET_STRING_set</tt></a></li>
          
            <li><a href="#ASN1_STRING_to_UTF8"><tt>ASN1_STRING_to_UTF8</tt></a></li>
          
            <li><a href="#MBSTRING_FLAG"><tt>MBSTRING_FLAG</tt></a></li>
          
            <li><a href="#MBSTRING_UTF8"><tt>MBSTRING_UTF8</tt></a></li>
          
            <li><a href="#MBSTRING_ASC"><tt>MBSTRING_ASC</tt></a></li>
          
            <li><a href="#MBSTRING_BMP"><tt>MBSTRING_BMP</tt></a></li>
          
            <li><a href="#MBSTRING_UNIV"><tt>MBSTRING_UNIV</tt></a></li>
          
            <li><a href="#DIRSTRING_TYPE"><tt>DIRSTRING_TYPE</tt></a></li>
          
            <li><a href="#PKCS9STRING_TYPE"><tt>PKCS9STRING_TYPE</tt></a></li>
          
            <li><a href="#ASN1_mbstring_copy"><tt>ASN1_mbstring_copy</tt></a></li>
          
            <li><a href="#ASN1_mbstring_ncopy"><tt>ASN1_mbstring_ncopy</tt></a></li>
          
            <li><a href="#ASN1_STRING_set_by_NID"><tt>ASN1_STRING_set_by_NID</tt></a></li>
          
            <li><a href="#STABLE_NO_MASK"><tt>STABLE_NO_MASK</tt></a></li>
          
            <li><a href="#ASN1_STRING_TABLE_add"><tt>ASN1_STRING_TABLE_add</tt></a></li>
          
        
      
        
          <li class="header"><a href="#Multi-strings">Multi-strings</a></li>
          
            <li><a href="#B_ASN1_DIRECTORYSTRING"><tt>B_ASN1_DIRECTORYSTRING</tt></a></li>
          
            <li><a href="#DIRECTORYSTRING_new"><tt>DIRECTORYSTRING_new</tt></a></li>
          
            <li><a href="#DIRECTORYSTRING_free"><tt>DIRECTORYSTRING_free</tt></a></li>
          
            <li><a href="#d2i_DIRECTORYSTRING"><tt>d2i_DIRECTORYSTRING</tt></a></li>
          
            <li><a href="#i2d_DIRECTORYSTRING"><tt>i2d_DIRECTORYSTRING</tt></a></li>
          
            
          
            <li><a href="#B_ASN1_DISPLAYTEXT"><tt>B_ASN1_DISPLAYTEXT</tt></a></li>
          
            <li><a href="#DISPLAYTEXT_new"><tt>DISPLAYTEXT_new</tt></a></li>
          
            <li><a href="#DISPLAYTEXT_free"><tt>DISPLAYTEXT_free</tt></a></li>
          
            <li><a href="#d2i_DISPLAYTEXT"><tt>d2i_DISPLAYTEXT</tt></a></li>
          
            <li><a href="#i2d_DISPLAYTEXT"><tt>i2d_DISPLAYTEXT</tt></a></li>
          
            
          
        
      
        
          <li class="header"><a href="#Bit-strings">Bit strings</a></li>
          
            <li><a href="#ASN1_BIT_STRING_new"><tt>ASN1_BIT_STRING_new</tt></a></li>
          
            <li><a href="#ASN1_BIT_STRING_free"><tt>ASN1_BIT_STRING_free</tt></a></li>
          
            <li><a href="#d2i_ASN1_BIT_STRING"><tt>d2i_ASN1_BIT_STRING</tt></a></li>
          
            <li><a href="#i2d_ASN1_BIT_STRING"><tt>i2d_ASN1_BIT_STRING</tt></a></li>
          
            <li><a href="#c2i_ASN1_BIT_STRING"><tt>c2i_ASN1_BIT_STRING</tt></a></li>
          
            <li><a href="#i2c_ASN1_BIT_STRING"><tt>i2c_ASN1_BIT_STRING</tt></a></li>
          
            
          
            <li><a href="#ASN1_BIT_STRING_num_bytes"><tt>ASN1_BIT_STRING_num_bytes</tt></a></li>
          
            <li><a href="#ASN1_BIT_STRING_set"><tt>ASN1_BIT_STRING_set</tt></a></li>
          
            <li><a href="#ASN1_BIT_STRING_set_bit"><tt>ASN1_BIT_STRING_set_bit</tt></a></li>
          
            <li><a href="#ASN1_BIT_STRING_get_bit"><tt>ASN1_BIT_STRING_get_bit</tt></a></li>
          
            <li><a href="#ASN1_BIT_STRING_check"><tt>ASN1_BIT_STRING_check</tt></a></li>
          
        
      
        
          <li class="header"><a href="#Integers-and-enumerated-values">Integers and enumerated values</a></li>
          
            
          
            <li><a href="#ASN1_INTEGER_new"><tt>ASN1_INTEGER_new</tt></a></li>
          
            <li><a href="#ASN1_INTEGER_free"><tt>ASN1_INTEGER_free</tt></a></li>
          
            <li><a href="#ASN1_INTEGER_dup"><tt>ASN1_INTEGER_dup</tt></a></li>
          
            <li><a href="#d2i_ASN1_INTEGER"><tt>d2i_ASN1_INTEGER</tt></a></li>
          
            <li><a href="#i2d_ASN1_INTEGER"><tt>i2d_ASN1_INTEGER</tt></a></li>
          
            <li><a href="#c2i_ASN1_INTEGER"><tt>c2i_ASN1_INTEGER</tt></a></li>
          
            <li><a href="#i2c_ASN1_INTEGER"><tt>i2c_ASN1_INTEGER</tt></a></li>
          
            
          
            <li><a href="#ASN1_INTEGER_set_uint64"><tt>ASN1_INTEGER_set_uint64</tt></a></li>
          
            <li><a href="#ASN1_INTEGER_set_int64"><tt>ASN1_INTEGER_set_int64</tt></a></li>
          
            <li><a href="#ASN1_INTEGER_get_uint64"><tt>ASN1_INTEGER_get_uint64</tt></a></li>
          
            <li><a href="#ASN1_INTEGER_get_int64"><tt>ASN1_INTEGER_get_int64</tt></a></li>
          
            <li><a href="#BN_to_ASN1_INTEGER"><tt>BN_to_ASN1_INTEGER</tt></a></li>
          
            <li><a href="#ASN1_INTEGER_to_BN"><tt>ASN1_INTEGER_to_BN</tt></a></li>
          
            <li><a href="#ASN1_INTEGER_cmp"><tt>ASN1_INTEGER_cmp</tt></a></li>
          
            <li><a href="#ASN1_ENUMERATED_new"><tt>ASN1_ENUMERATED_new</tt></a></li>
          
            <li><a href="#ASN1_ENUMERATED_free"><tt>ASN1_ENUMERATED_free</tt></a></li>
          
            <li><a href="#d2i_ASN1_ENUMERATED"><tt>d2i_ASN1_ENUMERATED</tt></a></li>
          
            <li><a href="#i2d_ASN1_ENUMERATED"><tt>i2d_ASN1_ENUMERATED</tt></a></li>
          
            
          
            <li><a href="#ASN1_ENUMERATED_set_uint64"><tt>ASN1_ENUMERATED_set_uint64</tt></a></li>
          
            <li><a href="#ASN1_ENUMERATED_set_int64"><tt>ASN1_ENUMERATED_set_int64</tt></a></li>
          
            <li><a href="#ASN1_ENUMERATED_get_uint64"><tt>ASN1_ENUMERATED_get_uint64</tt></a></li>
          
            <li><a href="#ASN1_ENUMERATED_get_int64"><tt>ASN1_ENUMERATED_get_int64</tt></a></li>
          
            <li><a href="#BN_to_ASN1_ENUMERATED"><tt>BN_to_ASN1_ENUMERATED</tt></a></li>
          
            <li><a href="#ASN1_ENUMERATED_to_BN"><tt>ASN1_ENUMERATED_to_BN</tt></a></li>
          
        
      
        
          <li class="header"><a href="#Time">Time</a></li>
          
            <li><a href="#ASN1_UTCTIME_new"><tt>ASN1_UTCTIME_new</tt></a></li>
          
            <li><a href="#ASN1_UTCTIME_free"><tt>ASN1_UTCTIME_free</tt></a></li>
          
            <li><a href="#d2i_ASN1_UTCTIME"><tt>d2i_ASN1_UTCTIME</tt></a></li>
          
            <li><a href="#i2d_ASN1_UTCTIME"><tt>i2d_ASN1_UTCTIME</tt></a></li>
          
            
          
            <li><a href="#ASN1_UTCTIME_check"><tt>ASN1_UTCTIME_check</tt></a></li>
          
            <li><a href="#ASN1_UTCTIME_set"><tt>ASN1_UTCTIME_set</tt></a></li>
          
            <li><a href="#ASN1_UTCTIME_adj"><tt>ASN1_UTCTIME_adj</tt></a></li>
          
            <li><a href="#ASN1_UTCTIME_set_string"><tt>ASN1_UTCTIME_set_string</tt></a></li>
          
            <li><a href="#ASN1_UTCTIME_cmp_time_t"><tt>ASN1_UTCTIME_cmp_time_t</tt></a></li>
          
            <li><a href="#ASN1_GENERALIZEDTIME_new"><tt>ASN1_GENERALIZEDTIME_new</tt></a></li>
          
            <li><a href="#ASN1_GENERALIZEDTIME_free"><tt>ASN1_GENERALIZEDTIME_free</tt></a></li>
          
            <li><a href="#d2i_ASN1_GENERALIZEDTIME"><tt>d2i_ASN1_GENERALIZEDTIME</tt></a></li>
          
            <li><a href="#i2d_ASN1_GENERALIZEDTIME"><tt>i2d_ASN1_GENERALIZEDTIME</tt></a></li>
          
            
          
            <li><a href="#ASN1_GENERALIZEDTIME_check"><tt>ASN1_GENERALIZEDTIME_check</tt></a></li>
          
            <li><a href="#ASN1_GENERALIZEDTIME_set"><tt>ASN1_GENERALIZEDTIME_set</tt></a></li>
          
            <li><a href="#ASN1_GENERALIZEDTIME_adj"><tt>ASN1_GENERALIZEDTIME_adj</tt></a></li>
          
            <li><a href="#ASN1_GENERALIZEDTIME_set_string"><tt>ASN1_GENERALIZEDTIME_set_string</tt></a></li>
          
            <li><a href="#B_ASN1_TIME"><tt>B_ASN1_TIME</tt></a></li>
          
            <li><a href="#ASN1_TIME_new"><tt>ASN1_TIME_new</tt></a></li>
          
            <li><a href="#ASN1_TIME_free"><tt>ASN1_TIME_free</tt></a></li>
          
            <li><a href="#d2i_ASN1_TIME"><tt>d2i_ASN1_TIME</tt></a></li>
          
            <li><a href="#i2d_ASN1_TIME"><tt>i2d_ASN1_TIME</tt></a></li>
          
            
          
            <li><a href="#ASN1_TIME_diff"><tt>ASN1_TIME_diff</tt></a></li>
          
            <li><a href="#ASN1_TIME_set_posix"><tt>ASN1_TIME_set_posix</tt></a></li>
          
            <li><a href="#ASN1_TIME_set"><tt>ASN1_TIME_set</tt></a></li>
          
            <li><a href="#ASN1_TIME_adj"><tt>ASN1_TIME_adj</tt></a></li>
          
            <li><a href="#ASN1_TIME_check"><tt>ASN1_TIME_check</tt></a></li>
          
            <li><a href="#ASN1_TIME_to_generalizedtime"><tt>ASN1_TIME_to_generalizedtime</tt></a></li>
          
            <li><a href="#ASN1_TIME_set_string"><tt>ASN1_TIME_set_string</tt></a></li>
          
        
      
        
          <li class="header"><a href="#ASN1_TIME-conversion-functions">ASN1_TIME conversion functions</a></li>
          
            <li><a href="#ASN1_TIME_to_tm"><tt>ASN1_TIME_to_tm</tt></a></li>
          
            <li><a href="#ASN1_TIME_set_string_X509"><tt>ASN1_TIME_set_string_X509</tt></a></li>
          
            <li><a href="#ASN1_TIME_to_time_t"><tt>ASN1_TIME_to_time_t</tt></a></li>
          
            <li><a href="#ASN1_TIME_to_posix"><tt>ASN1_TIME_to_posix</tt></a></li>
          
            
          
        
      
        
          <li class="header"><a href="#NULL-values">NULL values</a></li>
          
            <li><a href="#ASN1_NULL_new"><tt>ASN1_NULL_new</tt></a></li>
          
            <li><a href="#ASN1_NULL_free"><tt>ASN1_NULL_free</tt></a></li>
          
            <li><a href="#d2i_ASN1_NULL"><tt>d2i_ASN1_NULL</tt></a></li>
          
            <li><a href="#i2d_ASN1_NULL"><tt>i2d_ASN1_NULL</tt></a></li>
          
            
          
        
      
        
          <li class="header"><a href="#Object-identifiers">Object identifiers</a></li>
          
            
          
            <li><a href="#ASN1_OBJECT_create"><tt>ASN1_OBJECT_create</tt></a></li>
          
            <li><a href="#ASN1_OBJECT_free"><tt>ASN1_OBJECT_free</tt></a></li>
          
            <li><a href="#d2i_ASN1_OBJECT"><tt>d2i_ASN1_OBJECT</tt></a></li>
          
            <li><a href="#i2d_ASN1_OBJECT"><tt>i2d_ASN1_OBJECT</tt></a></li>
          
            <li><a href="#c2i_ASN1_OBJECT"><tt>c2i_ASN1_OBJECT</tt></a></li>
          
            
          
        
      
        
          <li class="header"><a href="#Arbitrary-elements">Arbitrary elements</a></li>
          
            <li><a href="#asn1_type_st"><tt>asn1_type_st</tt></a></li>
          
            <li><a href="#ASN1_TYPE_new"><tt>ASN1_TYPE_new</tt></a></li>
          
            <li><a href="#ASN1_TYPE_free"><tt>ASN1_TYPE_free</tt></a></li>
          
            <li><a href="#d2i_ASN1_TYPE"><tt>d2i_ASN1_TYPE</tt></a></li>
          
            <li><a href="#i2d_ASN1_TYPE"><tt>i2d_ASN1_TYPE</tt></a></li>
          
            
          
            <li><a href="#ASN1_TYPE_get"><tt>ASN1_TYPE_get</tt></a></li>
          
            <li><a href="#ASN1_TYPE_set"><tt>ASN1_TYPE_set</tt></a></li>
          
            <li><a href="#ASN1_TYPE_set1"><tt>ASN1_TYPE_set1</tt></a></li>
          
            <li><a href="#ASN1_TYPE_cmp"><tt>ASN1_TYPE_cmp</tt></a></li>
          
            <li><a href="#d2i_ASN1_SEQUENCE_ANY"><tt>d2i_ASN1_SEQUENCE_ANY</tt></a></li>
          
            <li><a href="#i2d_ASN1_SEQUENCE_ANY"><tt>i2d_ASN1_SEQUENCE_ANY</tt></a></li>
          
            <li><a href="#d2i_ASN1_SET_ANY"><tt>d2i_ASN1_SET_ANY</tt></a></li>
          
            <li><a href="#i2d_ASN1_SET_ANY"><tt>i2d_ASN1_SET_ANY</tt></a></li>
          
        
      
        
          <li class="header"><a href="#Human-readable-output">Human-readable output</a></li>
          
            <li><a href="#ASN1_UTCTIME_print"><tt>ASN1_UTCTIME_print</tt></a></li>
          
            <li><a href="#ASN1_GENERALIZEDTIME_print"><tt>ASN1_GENERALIZEDTIME_print</tt></a></li>
          
            <li><a href="#ASN1_TIME_print"><tt>ASN1_TIME_print</tt></a></li>
          
            <li><a href="#ASN1_STRING_print"><tt>ASN1_STRING_print</tt></a></li>
          
            
          
            <li><a href="#ASN1_STRFLGS_ESC_2253"><tt>ASN1_STRFLGS_ESC_2253</tt></a></li>
          
            <li><a href="#ASN1_STRFLGS_ESC_CTRL"><tt>ASN1_STRFLGS_ESC_CTRL</tt></a></li>
          
            <li><a href="#ASN1_STRFLGS_ESC_MSB"><tt>ASN1_STRFLGS_ESC_MSB</tt></a></li>
          
            <li><a href="#ASN1_STRFLGS_ESC_QUOTE"><tt>ASN1_STRFLGS_ESC_QUOTE</tt></a></li>
          
            <li><a href="#ASN1_STRFLGS_UTF8_CONVERT"><tt>ASN1_STRFLGS_UTF8_CONVERT</tt></a></li>
          
            <li><a href="#ASN1_STRFLGS_IGNORE_TYPE"><tt>ASN1_STRFLGS_IGNORE_TYPE</tt></a></li>
          
            <li><a href="#ASN1_STRFLGS_SHOW_TYPE"><tt>ASN1_STRFLGS_SHOW_TYPE</tt></a></li>
          
            <li><a href="#ASN1_STRFLGS_DUMP_ALL"><tt>ASN1_STRFLGS_DUMP_ALL</tt></a></li>
          
            <li><a href="#ASN1_STRFLGS_DUMP_UNKNOWN"><tt>ASN1_STRFLGS_DUMP_UNKNOWN</tt></a></li>
          
            <li><a href="#ASN1_STRFLGS_DUMP_DER"><tt>ASN1_STRFLGS_DUMP_DER</tt></a></li>
          
            <li><a href="#ASN1_STRFLGS_RFC2253"><tt>ASN1_STRFLGS_RFC2253</tt></a></li>
          
            <li><a href="#ASN1_STRING_print_ex"><tt>ASN1_STRING_print_ex</tt></a></li>
          
            <li><a href="#ASN1_STRING_print_ex_fp"><tt>ASN1_STRING_print_ex_fp</tt></a></li>
          
            <li><a href="#i2a_ASN1_INTEGER"><tt>i2a_ASN1_INTEGER</tt></a></li>
          
            <li><a href="#i2a_ASN1_ENUMERATED"><tt>i2a_ASN1_ENUMERATED</tt></a></li>
          
            <li><a href="#i2a_ASN1_OBJECT"><tt>i2a_ASN1_OBJECT</tt></a></li>
          
            <li><a href="#i2a_ASN1_STRING"><tt>i2a_ASN1_STRING</tt></a></li>
          
            <li><a href="#i2t_ASN1_OBJECT"><tt>i2t_ASN1_OBJECT</tt></a></li>
          
        
      
        
          <li class="header"><a href="#Low-level-encoding-functions">Low-level encoding functions</a></li>
          
            <li><a href="#ASN1_get_object"><tt>ASN1_get_object</tt></a></li>
          
            <li><a href="#ASN1_put_object"><tt>ASN1_put_object</tt></a></li>
          
            <li><a href="#ASN1_put_eoc"><tt>ASN1_put_eoc</tt></a></li>
          
            <li><a href="#ASN1_object_size"><tt>ASN1_object_size</tt></a></li>
          
        
      
        
          <li class="header"><a href="#Function-declaration-macros">Function declaration macros</a></li>
          
            <li><a href="#DECLARE_ASN1_FUNCTIONS"><tt>DECLARE_ASN1_FUNCTIONS</tt></a></li>
          
            <li><a href="#DECLARE_ASN1_ALLOC_FUNCTIONS"><tt>DECLARE_ASN1_ALLOC_FUNCTIONS</tt></a></li>
          
            <li><a href="#DECLARE_ASN1_FUNCTIONS_name"><tt>DECLARE_ASN1_FUNCTIONS_name</tt></a></li>
          
            <li><a href="#DECLARE_ASN1_FUNCTIONS_fname"><tt>DECLARE_ASN1_FUNCTIONS_fname</tt></a></li>
          
            <li><a href="#DECLARE_ASN1_ENCODE_FUNCTIONS"><tt>DECLARE_ASN1_ENCODE_FUNCTIONS</tt></a></li>
          
            <li><a href="#DECLARE_ASN1_ENCODE_FUNCTIONS_const"><tt>DECLARE_ASN1_ENCODE_FUNCTIONS_const</tt></a></li>
          
            <li><a href="#DECLARE_ASN1_FUNCTIONS_const"><tt>DECLARE_ASN1_FUNCTIONS_const</tt></a></li>
          
            <li><a href="#DECLARE_ASN1_ALLOC_FUNCTIONS_name"><tt>DECLARE_ASN1_ALLOC_FUNCTIONS_name</tt></a></li>
          
        
      
        
          <li class="header"><a href="#Deprecated-functions">Deprecated functions</a></li>
          
            <li><a href="#M_ASN1_STRING_length"><tt>M_ASN1_STRING_length</tt></a></li>
          
            <li><a href="#M_ASN1_STRING_type"><tt>M_ASN1_STRING_type</tt></a></li>
          
            <li><a href="#M_ASN1_STRING_data"><tt>M_ASN1_STRING_data</tt></a></li>
          
            <li><a href="#M_ASN1_BIT_STRING_new"><tt>M_ASN1_BIT_STRING_new</tt></a></li>
          
            <li><a href="#M_ASN1_BIT_STRING_free"><tt>M_ASN1_BIT_STRING_free</tt></a></li>
          
            <li><a href="#M_ASN1_BIT_STRING_dup"><tt>M_ASN1_BIT_STRING_dup</tt></a></li>
          
            <li><a href="#M_ASN1_BIT_STRING_cmp"><tt>M_ASN1_BIT_STRING_cmp</tt></a></li>
          
            <li><a href="#M_ASN1_BIT_STRING_set"><tt>M_ASN1_BIT_STRING_set</tt></a></li>
          
            <li><a href="#M_ASN1_INTEGER_new"><tt>M_ASN1_INTEGER_new</tt></a></li>
          
            <li><a href="#M_ASN1_INTEGER_free"><tt>M_ASN1_INTEGER_free</tt></a></li>
          
            <li><a href="#M_ASN1_INTEGER_dup"><tt>M_ASN1_INTEGER_dup</tt></a></li>
          
            <li><a href="#M_ASN1_INTEGER_cmp"><tt>M_ASN1_INTEGER_cmp</tt></a></li>
          
            <li><a href="#M_ASN1_ENUMERATED_new"><tt>M_ASN1_ENUMERATED_new</tt></a></li>
          
            <li><a href="#M_ASN1_ENUMERATED_free"><tt>M_ASN1_ENUMERATED_free</tt></a></li>
          
            <li><a href="#M_ASN1_ENUMERATED_dup"><tt>M_ASN1_ENUMERATED_dup</tt></a></li>
          
            <li><a href="#M_ASN1_ENUMERATED_cmp"><tt>M_ASN1_ENUMERATED_cmp</tt></a></li>
          
            <li><a href="#M_ASN1_OCTET_STRING_new"><tt>M_ASN1_OCTET_STRING_new</tt></a></li>
          
            <li><a href="#M_ASN1_OCTET_STRING_free"><tt>M_ASN1_OCTET_STRING_free</tt></a></li>
          
            <li><a href="#M_ASN1_OCTET_STRING_dup"><tt>M_ASN1_OCTET_STRING_dup</tt></a></li>
          
            <li><a href="#M_ASN1_OCTET_STRING_cmp"><tt>M_ASN1_OCTET_STRING_cmp</tt></a></li>
          
            <li><a href="#M_ASN1_OCTET_STRING_set"><tt>M_ASN1_OCTET_STRING_set</tt></a></li>
          
            <li><a href="#M_ASN1_OCTET_STRING_print"><tt>M_ASN1_OCTET_STRING_print</tt></a></li>
          
            <li><a href="#M_ASN1_PRINTABLESTRING_new"><tt>M_ASN1_PRINTABLESTRING_new</tt></a></li>
          
            <li><a href="#M_ASN1_PRINTABLESTRING_free"><tt>M_ASN1_PRINTABLESTRING_free</tt></a></li>
          
            <li><a href="#M_ASN1_IA5STRING_new"><tt>M_ASN1_IA5STRING_new</tt></a></li>
          
            <li><a href="#M_ASN1_IA5STRING_free"><tt>M_ASN1_IA5STRING_free</tt></a></li>
          
            <li><a href="#M_ASN1_IA5STRING_dup"><tt>M_ASN1_IA5STRING_dup</tt></a></li>
          
            <li><a href="#M_ASN1_UTCTIME_new"><tt>M_ASN1_UTCTIME_new</tt></a></li>
          
            <li><a href="#M_ASN1_UTCTIME_free"><tt>M_ASN1_UTCTIME_free</tt></a></li>
          
            <li><a href="#M_ASN1_UTCTIME_dup"><tt>M_ASN1_UTCTIME_dup</tt></a></li>
          
            <li><a href="#M_ASN1_T61STRING_new"><tt>M_ASN1_T61STRING_new</tt></a></li>
          
            <li><a href="#M_ASN1_T61STRING_free"><tt>M_ASN1_T61STRING_free</tt></a></li>
          
            <li><a href="#M_ASN1_GENERALIZEDTIME_new"><tt>M_ASN1_GENERALIZEDTIME_new</tt></a></li>
          
            <li><a href="#M_ASN1_GENERALIZEDTIME_free"><tt>M_ASN1_GENERALIZEDTIME_free</tt></a></li>
          
            <li><a href="#M_ASN1_GENERALIZEDTIME_dup"><tt>M_ASN1_GENERALIZEDTIME_dup</tt></a></li>
          
            <li><a href="#M_ASN1_GENERALSTRING_new"><tt>M_ASN1_GENERALSTRING_new</tt></a></li>
          
            <li><a href="#M_ASN1_GENERALSTRING_free"><tt>M_ASN1_GENERALSTRING_free</tt></a></li>
          
            <li><a href="#M_ASN1_UNIVERSALSTRING_new"><tt>M_ASN1_UNIVERSALSTRING_new</tt></a></li>
          
            <li><a href="#M_ASN1_UNIVERSALSTRING_free"><tt>M_ASN1_UNIVERSALSTRING_free</tt></a></li>
          
            <li><a href="#M_ASN1_BMPSTRING_new"><tt>M_ASN1_BMPSTRING_new</tt></a></li>
          
            <li><a href="#M_ASN1_BMPSTRING_free"><tt>M_ASN1_BMPSTRING_free</tt></a></li>
          
            <li><a href="#M_ASN1_VISIBLESTRING_new"><tt>M_ASN1_VISIBLESTRING_new</tt></a></li>
          
            <li><a href="#M_ASN1_VISIBLESTRING_free"><tt>M_ASN1_VISIBLESTRING_free</tt></a></li>
          
            <li><a href="#M_ASN1_UTF8STRING_new"><tt>M_ASN1_UTF8STRING_new</tt></a></li>
          
            <li><a href="#M_ASN1_UTF8STRING_free"><tt>M_ASN1_UTF8STRING_free</tt></a></li>
          
            <li><a href="#B_ASN1_PRINTABLE"><tt>B_ASN1_PRINTABLE</tt></a></li>
          
            <li><a href="#ASN1_PRINTABLE_new"><tt>ASN1_PRINTABLE_new</tt></a></li>
          
            <li><a href="#ASN1_PRINTABLE_free"><tt>ASN1_PRINTABLE_free</tt></a></li>
          
            <li><a href="#d2i_ASN1_PRINTABLE"><tt>d2i_ASN1_PRINTABLE</tt></a></li>
          
            <li><a href="#i2d_ASN1_PRINTABLE"><tt>i2d_ASN1_PRINTABLE</tt></a></li>
          
            
          
            <li><a href="#ASN1_INTEGER_set"><tt>ASN1_INTEGER_set</tt></a></li>
          
            <li><a href="#ASN1_ENUMERATED_set"><tt>ASN1_ENUMERATED_set</tt></a></li>
          
            <li><a href="#ASN1_INTEGER_get"><tt>ASN1_INTEGER_get</tt></a></li>
          
            <li><a href="#ASN1_ENUMERATED_get"><tt>ASN1_ENUMERATED_get</tt></a></li>
          
        
      
        
          <li class="header"><a href="#General-No-op-Functions-%5bDeprecated%5d">General No-op Functions [Deprecated]</a></li>
          
            <li><a href="#ASN1_STRING_set_default_mask"><tt>ASN1_STRING_set_default_mask</tt></a></li>
          
            <li><a href="#ASN1_STRING_set_default_mask_asc"><tt>ASN1_STRING_set_default_mask_asc</tt></a></li>
          
            <li><a href="#ASN1_STRING_get_default_mask"><tt>ASN1_STRING_get_default_mask</tt></a></li>
          
            <li><a href="#ASN1_STRING_TABLE_cleanup"><tt>ASN1_STRING_TABLE_cleanup</tt></a></li>
          
        
      
    </ol>

    
      
        <div class="section" id="Tag-constants">
        
          <div class="sectionpreamble">
          <p>Tag constants.</p><p>These constants are used in various APIs to specify ASN.1 types and tag components. See the specific API&#39;s documentation for details on which values are used and how.</p>
          </div>
        

        
          <div class="decl" id="V_ASN1_UNIVERSAL">
          
            <p>The following constants are tag classes.</p>
          
          <pre>#define V_ASN1_UNIVERSAL 0x00</pre>
          </div>
        
          <div class="decl" id="V_ASN1_APPLICATION">
          
          <pre>#define V_ASN1_APPLICATION 0x40</pre>
          </div>
        
          <div class="decl" id="V_ASN1_CONTEXT_SPECIFIC">
          
          <pre>#define V_ASN1_CONTEXT_SPECIFIC 0x80</pre>
          </div>
        
          <div class="decl" id="V_ASN1_PRIVATE">
          
          <pre>#define V_ASN1_PRIVATE 0xc0</pre>
          </div>
        
          <div class="decl" id="V_ASN1_CONSTRUCTED">
          
            <p><span class="first-word">V_ASN1_CONSTRUCTED</span> indicates an element is constructed, rather than primitive.</p>
          
          <pre>#define V_ASN1_CONSTRUCTED 0x20</pre>
          </div>
        
          <div class="decl" id="V_ASN1_PRIMITIVE_TAG">
          
            <p><span class="first-word">V_ASN1_PRIMITIVE_TAG</span> is the highest tag number which can be encoded in a single byte. Note this is unrelated to whether an element is constructed or primitive.</p>
          
            <p><span class="first-word">TODO(davidben):</span> Make this private.</p>
          
          <pre>#define V_ASN1_PRIMITIVE_TAG 0x1f</pre>
          </div>
        
          <div class="decl" id="V_ASN1_MAX_UNIVERSAL">
          
            <p><span class="first-word">V_ASN1_MAX_UNIVERSAL</span> is the highest supported universal tag number. It is necessary to avoid ambiguity with <tt><a href="asn1.h.html#V_ASN1_NEG">V_ASN1_NEG</a></tt> and <tt><a href="asn1.h.html#MBSTRING_FLAG">MBSTRING_FLAG</a></tt>.</p>
          
            <p><span class="first-word">TODO(davidben):</span> Make this private.</p>
          
          <pre>#define V_ASN1_MAX_UNIVERSAL 0xff</pre>
          </div>
        
          <div class="decl" id="V_ASN1_UNDEF">
          
            <p><span class="first-word">V_ASN1_UNDEF</span> is used in some APIs to indicate an ASN.1 element is omitted.</p>
          
          <pre>#define V_ASN1_UNDEF (-1)</pre>
          </div>
        
          <div class="decl" id="V_ASN1_OTHER">
          
            <p><span class="first-word">V_ASN1_OTHER</span> is used in <tt>ASN1_TYPE</tt> to indicate a non-universal ASN.1 type.</p>
          
          <pre>#define V_ASN1_OTHER (-3)</pre>
          </div>
        
          <div class="decl" id="V_ASN1_ANY">
          
            <p><span class="first-word">V_ASN1_ANY</span> is used by the ASN.1 templates to indicate an ANY type.</p>
          
          <pre>#define V_ASN1_ANY (-4)</pre>
          </div>
        
          <div class="decl" id="V_ASN1_EOC">
          
            <p>The following constants are tag numbers for universal types.</p>
          
          <pre>#define V_ASN1_EOC 0</pre>
          </div>
        
          <div class="decl" id="V_ASN1_BOOLEAN">
          
          <pre>#define V_ASN1_BOOLEAN 1</pre>
          </div>
        
          <div class="decl" id="V_ASN1_INTEGER">
          
          <pre>#define V_ASN1_INTEGER 2</pre>
          </div>
        
          <div class="decl" id="V_ASN1_BIT_STRING">
          
          <pre>#define V_ASN1_BIT_STRING 3</pre>
          </div>
        
          <div class="decl" id="V_ASN1_OCTET_STRING">
          
          <pre>#define V_ASN1_OCTET_STRING 4</pre>
          </div>
        
          <div class="decl" id="V_ASN1_NULL">
          
          <pre>#define V_ASN1_NULL 5</pre>
          </div>
        
          <div class="decl" id="V_ASN1_OBJECT">
          
          <pre>#define V_ASN1_OBJECT 6</pre>
          </div>
        
          <div class="decl" id="V_ASN1_OBJECT_DESCRIPTOR">
          
          <pre>#define V_ASN1_OBJECT_DESCRIPTOR 7</pre>
          </div>
        
          <div class="decl" id="V_ASN1_EXTERNAL">
          
          <pre>#define V_ASN1_EXTERNAL 8</pre>
          </div>
        
          <div class="decl" id="V_ASN1_REAL">
          
          <pre>#define V_ASN1_REAL 9</pre>
          </div>
        
          <div class="decl" id="V_ASN1_ENUMERATED">
          
          <pre>#define V_ASN1_ENUMERATED 10</pre>
          </div>
        
          <div class="decl" id="V_ASN1_UTF8STRING">
          
          <pre>#define V_ASN1_UTF8STRING 12</pre>
          </div>
        
          <div class="decl" id="V_ASN1_SEQUENCE">
          
          <pre>#define V_ASN1_SEQUENCE 16</pre>
          </div>
        
          <div class="decl" id="V_ASN1_SET">
          
          <pre>#define V_ASN1_SET 17</pre>
          </div>
        
          <div class="decl" id="V_ASN1_NUMERICSTRING">
          
          <pre>#define V_ASN1_NUMERICSTRING 18</pre>
          </div>
        
          <div class="decl" id="V_ASN1_PRINTABLESTRING">
          
          <pre>#define V_ASN1_PRINTABLESTRING 19</pre>
          </div>
        
          <div class="decl" id="V_ASN1_T61STRING">
          
          <pre>#define V_ASN1_T61STRING 20</pre>
          </div>
        
          <div class="decl" id="V_ASN1_TELETEXSTRING">
          
          <pre>#define V_ASN1_TELETEXSTRING 20</pre>
          </div>
        
          <div class="decl" id="V_ASN1_VIDEOTEXSTRING">
          
          <pre>#define V_ASN1_VIDEOTEXSTRING 21</pre>
          </div>
        
          <div class="decl" id="V_ASN1_IA5STRING">
          
          <pre>#define V_ASN1_IA5STRING 22</pre>
          </div>
        
          <div class="decl" id="V_ASN1_UTCTIME">
          
          <pre>#define V_ASN1_UTCTIME 23</pre>
          </div>
        
          <div class="decl" id="V_ASN1_GENERALIZEDTIME">
          
          <pre>#define V_ASN1_GENERALIZEDTIME 24</pre>
          </div>
        
          <div class="decl" id="V_ASN1_GRAPHICSTRING">
          
          <pre>#define V_ASN1_GRAPHICSTRING 25</pre>
          </div>
        
          <div class="decl" id="V_ASN1_ISO64STRING">
          
          <pre>#define V_ASN1_ISO64STRING 26</pre>
          </div>
        
          <div class="decl" id="V_ASN1_VISIBLESTRING">
          
          <pre>#define V_ASN1_VISIBLESTRING 26</pre>
          </div>
        
          <div class="decl" id="V_ASN1_GENERALSTRING">
          
          <pre>#define V_ASN1_GENERALSTRING 27</pre>
          </div>
        
          <div class="decl" id="V_ASN1_UNIVERSALSTRING">
          
          <pre>#define V_ASN1_UNIVERSALSTRING 28</pre>
          </div>
        
          <div class="decl" id="V_ASN1_BMPSTRING">
          
          <pre>#define V_ASN1_BMPSTRING 30</pre>
          </div>
        
          <div class="decl" id="V_ASN1_NEG">
          
            <p>The following constants are used for <tt>ASN1_STRING</tt> values that represent negative INTEGER and ENUMERATED values. See <tt>ASN1_STRING</tt> for more details.</p>
          
          <pre>#define V_ASN1_NEG 0x100</pre>
          </div>
        
          <div class="decl" id="V_ASN1_NEG_INTEGER">
          
          <pre>#define V_ASN1_NEG_INTEGER (V_ASN1_INTEGER | V_ASN1_NEG)</pre>
          </div>
        
          <div class="decl" id="V_ASN1_NEG_ENUMERATED">
          
          <pre>#define V_ASN1_NEG_ENUMERATED (V_ASN1_ENUMERATED | V_ASN1_NEG)</pre>
          </div>
        
          <div class="decl" id="B_ASN1_NUMERICSTRING">
          
            <p>The following constants are bitmask representations of ASN.1 types.</p>
          
          <pre>#define B_ASN1_NUMERICSTRING 0x0001</pre>
          </div>
        
          <div class="decl" id="B_ASN1_PRINTABLESTRING">
          
          <pre>#define B_ASN1_PRINTABLESTRING 0x0002</pre>
          </div>
        
          <div class="decl" id="B_ASN1_T61STRING">
          
          <pre>#define B_ASN1_T61STRING 0x0004</pre>
          </div>
        
          <div class="decl" id="B_ASN1_TELETEXSTRING">
          
          <pre>#define B_ASN1_TELETEXSTRING 0x0004</pre>
          </div>
        
          <div class="decl" id="B_ASN1_VIDEOTEXSTRING">
          
          <pre>#define B_ASN1_VIDEOTEXSTRING 0x0008</pre>
          </div>
        
          <div class="decl" id="B_ASN1_IA5STRING">
          
          <pre>#define B_ASN1_IA5STRING 0x0010</pre>
          </div>
        
          <div class="decl" id="B_ASN1_GRAPHICSTRING">
          
          <pre>#define B_ASN1_GRAPHICSTRING 0x0020</pre>
          </div>
        
          <div class="decl" id="B_ASN1_ISO64STRING">
          
          <pre>#define B_ASN1_ISO64STRING 0x0040</pre>
          </div>
        
          <div class="decl" id="B_ASN1_VISIBLESTRING">
          
          <pre>#define B_ASN1_VISIBLESTRING 0x0040</pre>
          </div>
        
          <div class="decl" id="B_ASN1_GENERALSTRING">
          
          <pre>#define B_ASN1_GENERALSTRING 0x0080</pre>
          </div>
        
          <div class="decl" id="B_ASN1_UNIVERSALSTRING">
          
          <pre>#define B_ASN1_UNIVERSALSTRING 0x0100</pre>
          </div>
        
          <div class="decl" id="B_ASN1_OCTET_STRING">
          
          <pre>#define B_ASN1_OCTET_STRING 0x0200</pre>
          </div>
        
          <div class="decl" id="B_ASN1_BIT_STRING">
          
          <pre>#define B_ASN1_BIT_STRING 0x0400</pre>
          </div>
        
          <div class="decl" id="B_ASN1_BMPSTRING">
          
          <pre>#define B_ASN1_BMPSTRING 0x0800</pre>
          </div>
        
          <div class="decl" id="B_ASN1_UNKNOWN">
          
          <pre>#define B_ASN1_UNKNOWN 0x1000</pre>
          </div>
        
          <div class="decl" id="B_ASN1_UTF8STRING">
          
          <pre>#define B_ASN1_UTF8STRING 0x2000</pre>
          </div>
        
          <div class="decl" id="B_ASN1_UTCTIME">
          
          <pre>#define B_ASN1_UTCTIME 0x4000</pre>
          </div>
        
          <div class="decl" id="B_ASN1_GENERALIZEDTIME">
          
          <pre>#define B_ASN1_GENERALIZEDTIME 0x8000</pre>
          </div>
        
          <div class="decl" id="B_ASN1_SEQUENCE">
          
          <pre>#define B_ASN1_SEQUENCE 0x10000</pre>
          </div>
        
          <div class="decl" id="ASN1_tag2bit">
          
            <p><span class="first-word">ASN1_tag2bit</span> converts <tt>tag</tt> from the tag number of a universal type to a corresponding <tt>B_ASN1_*</tt> constant, <tt><a href="asn1.h.html#B_ASN1_UNKNOWN">B_ASN1_UNKNOWN</a></tt>, or zero. If the <tt>B_ASN1_*</tt> constant above is defined, it will map the corresponding <tt>V_ASN1_*</tt> constant to it. Otherwise, whether it returns <tt><a href="asn1.h.html#B_ASN1_UNKNOWN">B_ASN1_UNKNOWN</a></tt> or zero is ill-defined and callers should not rely on it.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/412):</span> Figure out what <tt>B_ASN1_UNNOWN</tt> vs zero is meant to be. The main impact is what values go in <tt><a href="asn1.h.html#B_ASN1_PRINTABLE">B_ASN1_PRINTABLE</a></tt>. To that end, we must return zero on types that can&#39;t go in <tt>ASN1_STRING</tt>.</p>
          
          <pre>OPENSSL_EXPORT unsigned long ASN1_tag2bit(int tag);</pre>
          </div>
        
          <div class="decl" id="ASN1_tag2str">
          
            <p><span class="first-word">ASN1_tag2str</span> returns a string representation of <tt>tag</tt>, interpret as a tag number for a universal type, or <tt>V_ASN1_NEG_*</tt>.</p>
          
          <pre>OPENSSL_EXPORT const char *ASN1_tag2str(int tag);</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="API-conventions">
        
          <div class="sectionpreamble">
          <p>API conventions.</p><p>The following sample functions document the calling conventions used by legacy ASN.1 APIs.</p>
          </div>
        

        
          <div class="decl" >
          
          <pre>#if 0  // Sample functions</pre>
          </div>
        
          <div class="decl" id="d2i_SAMPLE">
          
            <p><span class="first-word">d2i_SAMPLE</span> parses a structure from up to <tt>len</tt> bytes at <tt>*inp</tt>. On success, it advances <tt>*inp</tt> by the number of bytes read and returns a newly-allocated <tt>SAMPLE</tt> object containing the parsed structure. If <tt>out</tt> is non-NULL, it additionally frees the previous value at <tt>*out</tt> and updates <tt>*out</tt> to the result. If parsing or allocating the result fails, it returns NULL.</p>
          
            <p><span class="first-word">This</span> function does not reject trailing data in the input. This allows the caller to parse a sequence of concatenated structures. Callers parsing only one structure should check for trailing data by comparing the updated <tt>*inp</tt> with the end of the input.</p>
          
            <p><span class="first-word">Note:</span> If <tt>out</tt> and <tt>*out</tt> are both non-NULL, the object at <tt>*out</tt> is not updated in-place. Instead, it is freed, and the pointer is updated to the new object. This differs from OpenSSL, which behaves more like <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>. Callers are recommended to set <tt>out</tt> to NULL and instead use the return value.</p>
          
          <pre>SAMPLE *d2i_SAMPLE(SAMPLE **out, const uint8_t **inp, long len);</pre>
          </div>
        
          <div class="decl" id="d2i_SAMPLE_with_reuse">
          
            <p><span class="first-word">d2i_SAMPLE_with_reuse</span> parses a structure from up to <tt>len</tt> bytes at <tt>*inp</tt>. On success, it advances <tt>*inp</tt> by the number of bytes read and returns a non-NULL pointer to an object containing the parsed structure. The object is determined from <tt>out</tt> as follows:</p>
          
            <p><span class="first-word">If</span> <tt>out</tt> is NULL, the function places the result in a newly-allocated <tt>SAMPLE</tt> object and returns it. This mode is recommended.</p>
          
            <p><span class="first-word">If</span> <tt>out</tt> is non-NULL, but <tt>*out</tt> is NULL, the function also places the result in a newly-allocated <tt>SAMPLE</tt> object. It sets <tt>*out</tt> to this object and also returns it.</p>
          
            <p><span class="first-word">If</span> <tt>out</tt> and <tt>*out</tt> are both non-NULL, the function updates the object at <tt>*out</tt> in-place with the result and returns <tt>*out</tt>.</p>
          
            <p><span class="first-word">If</span> any of the above fail, the function returns NULL.</p>
          
            <p><span class="first-word">This</span> function does not reject trailing data in the input. This allows the caller to parse a sequence of concatenated structures. Callers parsing only one structure should check for trailing data by comparing the updated <tt>*inp</tt> with the end of the input.</p>
          
            <p><span class="first-word">WARNING:</span> Callers should not rely on the in-place update mode. It often produces the wrong result or breaks the type&#39;s internal invariants. Future revisions of BoringSSL may standardize on the <tt><a href="asn1.h.html#d2i_SAMPLE">d2i_SAMPLE</a></tt> behavior.</p>
          
          <pre>SAMPLE *d2i_SAMPLE_with_reuse(SAMPLE **out, const uint8_t **inp, long len);</pre>
          </div>
        
          <div class="decl" id="i2d_SAMPLE">
          
            <p><span class="first-word">i2d_SAMPLE</span> marshals <tt>in</tt>. On error, it returns a negative value. On success, it returns the length of the result and outputs it via <tt>outp</tt> as follows:</p>
          
            <p><span class="first-word">If</span> <tt>outp</tt> is NULL, the function writes nothing. This mode can be used to size buffers.</p>
          
            <p><span class="first-word">If</span> <tt>outp</tt> is non-NULL but <tt>*outp</tt> is NULL, the function sets <tt>*outp</tt> to a newly-allocated buffer containing the result. The caller is responsible for releasing <tt>*outp</tt> with <tt><a href="mem.h.html#OPENSSL_free">OPENSSL_free</a></tt>. This mode is recommended for most callers.</p>
          
            <p><span class="first-word">If</span> <tt>outp</tt> and <tt>*outp</tt> are non-NULL, the function writes the result to <tt>*outp</tt>, which must have enough space available, and advances <tt>*outp</tt> just past the output.</p>
          
            <p><span class="first-word">WARNING:</span> In the third mode, the function does not internally check output bounds. Failing to correctly size the buffer will result in a potentially exploitable memory error.</p>
          
          <pre>int i2d_SAMPLE(const SAMPLE *in, uint8_t **outp);
#endif  // Sample functions</pre>
          </div>
        
          <div class="decl" id="I2D_OF">
          
            <p>The following macros are used to retrieve the function pointer of the <tt>d2i</tt> or <tt>i2d</tt> ASN1 functions of <tt>type</tt>.</p>
          
            <p><span class="first-word">NOTE:</span> <tt>D2I_OF</tt> and <tt>I2D_OF_const</tt> are not implemented.</p>
          
          <pre>#define I2D_OF(type) int (*)(type *, unsigned char **)</pre>
          </div>
        
          <div class="decl" id="CHECKED_I2D_OF">
          
            <p><span class="first-word">CHECKED_I2D_OF</span> casts a given pointer to i2d_of_void* and statically checks that it was a pointer to <tt>type</tt>&#39;s <tt>i2d</tt> function.</p>
          
          <pre>#define CHECKED_I2D_OF(type, i2d) \
    ((i2d_of_void*) (1 ? i2d : ((I2D_OF(type))0)))</pre>
          </div>
        
          <div class="decl" >
          
            <p>The following typedefs are sometimes used for pointers to functions like <tt><a href="asn1.h.html#d2i_SAMPLE">d2i_SAMPLE</a></tt> and <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>. Note, however, that these act on <tt>void*</tt>. Calling a function with a different pointer type is undefined in C, so this is only valid with a wrapper.</p>
          
          <pre>typedef void *d2i_of_void(void **, const unsigned char **, long);
typedef int i2d_of_void(const void *, unsigned char **);</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="ASN.1-types">
        
          <div class="sectionpreamble">
          <p>ASN.1 types.</p><p>An <tt>ASN1_ITEM</tt> represents an ASN.1 type and allows working with ASN.1 types generically.</p><p><tt>ASN1_ITEM</tt>s use a different namespace from C types and are accessed via <tt>ASN1_ITEM_*</tt> macros. So, for example, <tt>ASN1_OCTET_STRING</tt> is both a C type and the name of an <tt>ASN1_ITEM</tt>, referenced as <tt>ASN1_ITEM_rptr(ASN1_OCTET_STRING)</tt>.</p><p>Each <tt>ASN1_ITEM</tt> has a corresponding C type, typically with the same name, which represents values in the ASN.1 type. This type is either a pointer type or <tt>ASN1_BOOLEAN</tt>. When it is a pointer, NULL pointers represent omitted values. For example, an OCTET STRING value is declared with the C type <tt>ASN1_OCTET_STRING*</tt> and uses the <tt>ASN1_ITEM</tt> named <tt>ASN1_OCTET_STRING</tt>. An OPTIONAL OCTET STRING uses the same C type and represents an omitted value with a NULL pointer. <tt>ASN1_BOOLEAN</tt> is described in a later section.</p>
          </div>
        

        
          <div class="decl" id="DECLARE_ASN1_ITEM">
          
            <p><span class="first-word">DECLARE_ASN1_ITEM</span> declares an <tt>ASN1_ITEM</tt> with name <tt>name</tt>. The <tt>ASN1_ITEM</tt> may be referenced with <tt><a href="asn1.h.html#ASN1_ITEM_rptr">ASN1_ITEM_rptr</a></tt>. Uses of this macro should document the corresponding ASN.1 and C types.</p>
          
          <pre>#define DECLARE_ASN1_ITEM(name) extern OPENSSL_EXPORT const ASN1_ITEM name##_it;</pre>
          </div>
        
          <div class="decl" id="ASN1_ITEM_rptr">
          
            <p><span class="first-word">ASN1_ITEM_rptr</span> returns the |const ASN1_ITEM *| named <tt>name</tt>.</p>
          
          <pre>#define ASN1_ITEM_rptr(name) (&amp;(name##_it))</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">ASN1_ITEM_EXP</span> is an abstraction for referencing an <tt>ASN1_ITEM</tt> in a constant-initialized structure, such as a method table. It exists because, on some OpenSSL platforms, <tt>ASN1_ITEM</tt> references are indirected through functions. Structures reference the <tt>ASN1_ITEM</tt> by declaring a field like |ASN1_ITEM_EXP *item| and initializing it with <tt><a href="asn1.h.html#ASN1_ITEM_ref">ASN1_ITEM_ref</a></tt>.</p>
          
          <pre>typedef const ASN1_ITEM ASN1_ITEM_EXP;</pre>
          </div>
        
          <div class="decl" id="ASN1_ITEM_ref">
          
            <p><span class="first-word">ASN1_ITEM_ref</span> returns an <tt>ASN1_ITEM_EXP*</tt> for the <tt>ASN1_ITEM</tt> named <tt>name</tt>.</p>
          
          <pre>#define ASN1_ITEM_ref(name) (&amp;(name##_it))</pre>
          </div>
        
          <div class="decl" id="ASN1_ITEM_ptr">
          
            <p><span class="first-word">ASN1_ITEM_ptr</span> converts <tt>iptr</tt>, which must be an <tt>ASN1_ITEM_EXP*</tt> to a |const ASN1_ITEM*|.</p>
          
          <pre>#define ASN1_ITEM_ptr(iptr) (iptr)</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">ASN1_VALUE_st</span> (aka <tt>ASN1_VALUE</tt>) is an opaque type used as a placeholder for the C type corresponding to an <tt>ASN1_ITEM</tt>.</p>
          
          <pre>typedef struct ASN1_VALUE_st ASN1_VALUE;</pre>
          </div>
        
          <div class="decl" id="ASN1_item_new">
          
            <p><span class="first-word">ASN1_item_new</span> allocates a new value of the C type corresponding to <tt>it</tt>, or NULL on error. On success, the caller must release the value with <tt><a href="asn1.h.html#ASN1_item_free">ASN1_item_free</a></tt>, or the corresponding C type&#39;s free function, when done. The new value will initialize fields of the value to some default state, such as an empty string. Note, however, that this default state sometimes omits required values, such as with CHOICE types.</p>
          
            <p><span class="first-word">This</span> function may not be used with <tt>ASN1_ITEM</tt>s whose C type is <tt>ASN1_BOOLEAN</tt>.</p>
          
            <p><span class="first-word">WARNING:</span> Casting the result of this function to the wrong type is a potentially exploitable memory error. Callers must ensure the value is used consistently with <tt>it</tt>. Prefer using type-specific functions such as <tt><a href="asn1.h.html#ASN1_OCTET_STRING_new">ASN1_OCTET_STRING_new</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT ASN1_VALUE *ASN1_item_new(const ASN1_ITEM *it);</pre>
          </div>
        
          <div class="decl" id="ASN1_item_free">
          
            <p><span class="first-word">ASN1_item_free</span> releases memory associated with <tt>val</tt>, which must be an object of the C type corresponding to <tt>it</tt>.</p>
          
            <p><span class="first-word">This</span> function may not be used with <tt>ASN1_ITEM</tt>s whose C type is <tt>ASN1_BOOLEAN</tt>.</p>
          
            <p><span class="first-word">WARNING:</span> Passing a pointer of the wrong type into this function is a potentially exploitable memory error. Callers must ensure <tt>val</tt> is consistent with <tt>it</tt>. Prefer using type-specific functions such as <tt><a href="asn1.h.html#ASN1_OCTET_STRING_free">ASN1_OCTET_STRING_free</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it);</pre>
          </div>
        
          <div class="decl" id="ASN1_item_d2i">
          
            <p><span class="first-word">ASN1_item_d2i</span> parses the ASN.1 type <tt>it</tt> from up to <tt>len</tt> bytes at <tt>*inp</tt>. It behaves like <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>, except that <tt>out</tt> and the return value are cast to <tt>ASN1_VALUE</tt> pointers.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/444):</span> C strict aliasing forbids type-punning <tt>T*</tt> and <tt>ASN1_VALUE*</tt> the way this function signature does. When that bug is resolved, we will need to pick which type <tt>*out</tt> is (probably <tt>T*</tt>). Do not use a non-NULL <tt>out</tt> to avoid ending up on the wrong side of this question.</p>
          
            <p><span class="first-word">This</span> function may not be used with <tt>ASN1_ITEM</tt>s whose C type is <tt>ASN1_BOOLEAN</tt>.</p>
          
            <p><span class="first-word">WARNING:</span> Casting the result of this function to the wrong type, or passing a pointer of the wrong type into this function, are potentially exploitable memory errors. Callers must ensure <tt>out</tt> is consistent with <tt>it</tt>. Prefer using type-specific functions such as <tt><a href="asn1.h.html#d2i_ASN1_OCTET_STRING">d2i_ASN1_OCTET_STRING</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **out,
                                         const unsigned char **inp, long len,
                                         const ASN1_ITEM *it);</pre>
          </div>
        
          <div class="decl" id="ASN1_item_i2d">
          
            <p><span class="first-word">ASN1_item_i2d</span> marshals <tt>val</tt> as the ASN.1 type associated with <tt>it</tt>, as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
            <p><span class="first-word">This</span> function may not be used with <tt>ASN1_ITEM</tt>s whose C type is <tt>ASN1_BOOLEAN</tt>.</p>
          
            <p><span class="first-word">WARNING:</span> Passing a pointer of the wrong type into this function is a potentially exploitable memory error. Callers must ensure <tt>val</tt> is consistent with <tt>it</tt>. Prefer using type-specific functions such as <tt><a href="asn1.h.html#i2d_ASN1_OCTET_STRING">i2d_ASN1_OCTET_STRING</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_item_i2d(ASN1_VALUE *val, unsigned char **outp,
                                 const ASN1_ITEM *it);</pre>
          </div>
        
          <div class="decl" id="ASN1_item_dup">
          
            <p><span class="first-word">ASN1_item_dup</span> returns a newly-allocated copy of <tt>x</tt>, or NULL on error. <tt>x</tt> must be an object of <tt>it</tt>&#39;s C type.</p>
          
            <p><span class="first-word">This</span> function may not be used with <tt>ASN1_ITEM</tt>s whose C type is <tt>ASN1_BOOLEAN</tt>.</p>
          
            <p><span class="first-word">WARNING:</span> Casting the result of this function to the wrong type, or passing a pointer of the wrong type into this function, are potentially exploitable memory errors. Prefer using type-specific functions such as <tt><a href="asn1.h.html#ASN1_STRING_dup">ASN1_STRING_dup</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT void *ASN1_item_dup(const ASN1_ITEM *it, void *x);</pre>
          </div>
        
          <div class="decl" id="ASN1_item_d2i_fp">
          
            <p>The following functions behave like <tt><a href="asn1.h.html#ASN1_item_d2i">ASN1_item_d2i</a></tt> but read from <tt>in</tt> instead. <tt>out</tt> is the same parameter as in <tt><a href="asn1.h.html#ASN1_item_d2i">ASN1_item_d2i</a></tt>, but written with <tt>void*</tt> instead. The return values similarly match.</p>
          
            <p>These functions may not be used with <tt>ASN1_ITEM</tt>s whose C type is <tt>ASN1_BOOLEAN</tt>.</p>
          
            <p><span class="first-word">WARNING:</span> These functions do not bound how much data is read from <tt>in</tt>. Parsing an untrusted input could consume unbounded memory.</p>
          
          <pre>OPENSSL_EXPORT void *ASN1_item_d2i_fp(const ASN1_ITEM *it, FILE *in, void *out);</pre>
          </div>
        
          <div class="decl" id="ASN1_item_d2i_bio">
          
          <pre>OPENSSL_EXPORT void *ASN1_item_d2i_bio(const ASN1_ITEM *it, BIO *in, void *out);</pre>
          </div>
        
          <div class="decl" id="ASN1_item_i2d_fp">
          
            <p>The following functions behave like <tt><a href="asn1.h.html#ASN1_item_i2d">ASN1_item_i2d</a></tt> but write to <tt>out</tt> instead. <tt>in</tt> is the same parameter as in <tt><a href="asn1.h.html#ASN1_item_i2d">ASN1_item_i2d</a></tt>, but written with <tt>void*</tt> instead.</p>
          
            <p>These functions may not be used with <tt>ASN1_ITEM</tt>s whose C type is <tt>ASN1_BOOLEAN</tt>.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_item_i2d_fp(const ASN1_ITEM *it, FILE *out, void *in);</pre>
          </div>
        
          <div class="decl" id="ASN1_item_i2d_bio">
          
          <pre>OPENSSL_EXPORT int ASN1_item_i2d_bio(const ASN1_ITEM *it, BIO *out, void *in);</pre>
          </div>
        
          <div class="decl" id="ASN1_i2d_bio">
          
            <p><span class="first-word">ASN1_i2d_bio</span> writes the result to <tt>out</tt> like the functions above, but parses <tt>in</tt> with <tt>i2d</tt>.</p>
          
            <p><span class="first-word">WARNING:</span> Prefer using type-specific functions. <tt>i2d</tt> is only valid with a wrapper (see <tt>d2i_of_void</tt>).</p>
          
          <pre>OPENSSL_EXPORT int ASN1_i2d_bio(i2d_of_void *i2d, BIO *out, void *in);</pre>
          </div>
        
          <div class="decl" id="ASN1_i2d_bio_of">
          
            <p><span class="first-word">ASN1_i2d_bio_of</span> statically checks <tt>i2d</tt> and <tt>in</tt> for <tt>type</tt> before casting and calling <tt><a href="asn1.h.html#ASN1_i2d_bio">ASN1_i2d_bio</a></tt>.</p>
          
            <p><span class="first-word">DO</span> NOT USE: This is only maintained for compatibility purposes. Calling a function with a different pointer type is undefined behavior in C (see <tt>d2i_of_void</tt>). This macro forces the user to directly call the <tt>i2d</tt> ASN.1 function of <tt>type</tt>. <tt>i2d</tt> functions of <tt>type</tt> are defined with parameters of |type *|, but <tt>i2d_of_void</tt> expects the signature of a |const void *|. This inherently forces the user to use undefined C behavior and will cause failures when running against undefined behavior sanitizers in clang.</p>
          
          <pre>#define ASN1_i2d_bio_of(type, i2d, out, in) \
    (ASN1_i2d_bio(CHECKED_I2D_OF(type, i2d), out, CHECKED_PTR_OF(type, in)))</pre>
          </div>
        
          <div class="decl" id="ASN1_item_unpack">
          
            <p><span class="first-word">ASN1_item_unpack</span> parses <tt>oct</tt>&#39;s contents as <tt>it</tt>&#39;s ASN.1 type. It returns a newly-allocated instance of <tt>it</tt>&#39;s C type on success, or NULL on error.</p>
          
            <p><span class="first-word">This</span> function may not be used with <tt>ASN1_ITEM</tt>s whose C type is <tt>ASN1_BOOLEAN</tt>.</p>
          
            <p><span class="first-word">WARNING:</span> Casting the result of this function to the wrong type is a potentially exploitable memory error. Callers must ensure the value is used consistently with <tt>it</tt>.</p>
          
          <pre>OPENSSL_EXPORT void *ASN1_item_unpack(const ASN1_STRING *oct,
                                      const ASN1_ITEM *it);</pre>
          </div>
        
          <div class="decl" id="ASN1_item_pack">
          
            <p><span class="first-word">ASN1_item_pack</span> marshals <tt>obj</tt> as <tt>it</tt>&#39;s ASN.1 type. If <tt>out</tt> is NULL, it returns a newly-allocated <tt>ASN1_STRING</tt> with the result, or NULL on error. If <tt>out</tt> is non-NULL, but <tt>*out</tt> is NULL, it does the same but additionally sets <tt>*out</tt> to the result. If both <tt>out</tt> and <tt>*out</tt> are non-NULL, it writes the result to <tt>*out</tt> and returns <tt>*out</tt> on success or NULL on error.</p>
          
            <p><span class="first-word">This</span> function may not be used with <tt>ASN1_ITEM</tt>s whose C type is <tt>ASN1_BOOLEAN</tt>.</p>
          
            <p><span class="first-word">WARNING:</span> Passing a pointer of the wrong type into this function is a potentially exploitable memory error. Callers must ensure <tt>val</tt> is consistent with <tt>it</tt>.</p>
          
          <pre>OPENSSL_EXPORT ASN1_STRING *ASN1_item_pack(void *obj, const ASN1_ITEM *it,
                                           ASN1_STRING **out);</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="Booleans">
        
          <div class="sectionpreamble">
          <p>Booleans.</p><p>This library represents ASN.1 BOOLEAN values with <tt>ASN1_BOOLEAN</tt>, which is an integer type. FALSE is zero, TRUE is 0xff, and an omitted OPTIONAL BOOLEAN is -1.</p>
          </div>
        

        
          <div class="decl" id="ASN1_BOOLEAN_FALSE">
          
            <p><span class="first-word">ASN1_BOOLEAN_FALSE</span> is FALSE as an <tt>ASN1_BOOLEAN</tt>.</p>
          
          <pre>#define ASN1_BOOLEAN_FALSE 0</pre>
          </div>
        
          <div class="decl" id="ASN1_BOOLEAN_TRUE">
          
            <p><span class="first-word">ASN1_BOOLEAN_TRUE</span> is TRUE as an <tt>ASN1_BOOLEAN</tt>. Some code incorrectly uses 1, so prefer |b != ASN1_BOOLEAN_FALSE| over |b == ASN1_BOOLEAN_TRUE|.</p>
          
          <pre>#define ASN1_BOOLEAN_TRUE 0xff</pre>
          </div>
        
          <div class="decl" id="ASN1_BOOLEAN_NONE">
          
            <p><span class="first-word">ASN1_BOOLEAN_NONE,</span> in contexts where the <tt>ASN1_BOOLEAN</tt> represents an OPTIONAL BOOLEAN, is an omitted value. Using this value in other contexts is undefined and may be misinterpreted as TRUE.</p>
          
          <pre>#define ASN1_BOOLEAN_NONE (-1)</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_BOOLEAN">
          
            <p><span class="first-word">d2i_ASN1_BOOLEAN</span> parses a DER-encoded ASN.1 BOOLEAN from up to <tt>len</tt> bytes at <tt>*inp</tt>. On success, it advances <tt>*inp</tt> by the number of bytes read and returns the result. If <tt>out</tt> is non-NULL, it additionally writes the result to <tt>*out</tt>. On error, it returns <tt><a href="asn1.h.html#ASN1_BOOLEAN_NONE">ASN1_BOOLEAN_NONE</a></tt>.</p>
          
            <p><span class="first-word">This</span> function does not reject trailing data in the input. This allows the caller to parse a sequence of concatenated structures. Callers parsing only one structure should check for trailing data by comparing the updated <tt>*inp</tt> with the end of the input.</p>
          
            <p><span class="first-word">WARNING:</span> This function&#39;s is slightly different from other <tt>d2i_*</tt> functions because <tt>ASN1_BOOLEAN</tt> is not a pointer type.</p>
          
          <pre>OPENSSL_EXPORT ASN1_BOOLEAN d2i_ASN1_BOOLEAN(ASN1_BOOLEAN *out,
                                             const unsigned char **inp,
                                             long len);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_BOOLEAN">
          
            <p><span class="first-word">i2d_ASN1_BOOLEAN</span> marshals <tt>a</tt> as a DER-encoded ASN.1 BOOLEAN, as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_BOOLEAN(ASN1_BOOLEAN a, unsigned char **outp);</pre>
          </div>
        
          <div class="decl" >
          
            <p>The following <tt>ASN1_ITEM</tt>s have ASN.1 type BOOLEAN and C type <tt>ASN1_BOOLEAN</tt>. <tt>ASN1_TBOOLEAN</tt> and <tt>ASN1_FBOOLEAN</tt> must be marked OPTIONAL. When omitted, they are parsed as TRUE and FALSE, respectively, rather than <tt><a href="asn1.h.html#ASN1_BOOLEAN_NONE">ASN1_BOOLEAN_NONE</a></tt>.</p>
          
          <pre>DECLARE_ASN1_ITEM(ASN1_BOOLEAN)
DECLARE_ASN1_ITEM(ASN1_TBOOLEAN)
DECLARE_ASN1_ITEM(ASN1_FBOOLEAN)</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="Strings">
        
          <div class="sectionpreamble">
          <p>Strings.</p><p>ASN.1 contains a myriad of string types, as well as types that contain data that may be encoded into a string. This library uses a single type, <tt>ASN1_STRING</tt>, to represent most values.</p>
          </div>
        

        
          <div class="decl" id="asn1_string_st">
          
            <p>An <span class="first-word">asn1_string_st</span> (aka <tt>ASN1_STRING</tt>) represents a value of a string-like ASN.1 type. It contains a type field, and a byte string data field with a type-specific representation.</p>
          
            <p><span class="first-word">When</span> representing a string value, the type field is one of <tt><a href="asn1.h.html#V_ASN1_OCTET_STRING">V_ASN1_OCTET_STRING</a></tt>, <tt><a href="asn1.h.html#V_ASN1_UTF8STRING">V_ASN1_UTF8STRING</a></tt>, <tt><a href="asn1.h.html#V_ASN1_NUMERICSTRING">V_ASN1_NUMERICSTRING</a></tt>, <tt><a href="asn1.h.html#V_ASN1_PRINTABLESTRING">V_ASN1_PRINTABLESTRING</a></tt>, <tt><a href="asn1.h.html#V_ASN1_T61STRING">V_ASN1_T61STRING</a></tt>, <tt><a href="asn1.h.html#V_ASN1_VIDEOTEXSTRING">V_ASN1_VIDEOTEXSTRING</a></tt>, <tt><a href="asn1.h.html#V_ASN1_IA5STRING">V_ASN1_IA5STRING</a></tt>, <tt><a href="asn1.h.html#V_ASN1_GRAPHICSTRING">V_ASN1_GRAPHICSTRING</a></tt>, <tt><a href="asn1.h.html#V_ASN1_ISO64STRING">V_ASN1_ISO64STRING</a></tt>, <tt><a href="asn1.h.html#V_ASN1_VISIBLESTRING">V_ASN1_VISIBLESTRING</a></tt>, <tt><a href="asn1.h.html#V_ASN1_GENERALSTRING">V_ASN1_GENERALSTRING</a></tt>, <tt><a href="asn1.h.html#V_ASN1_UNIVERSALSTRING">V_ASN1_UNIVERSALSTRING</a></tt>, or <tt><a href="asn1.h.html#V_ASN1_BMPSTRING">V_ASN1_BMPSTRING</a></tt>. The data contains the byte representation of of the string.</p>
          
            <p><span class="first-word">When</span> representing a BIT STRING value, the type field is <tt><a href="asn1.h.html#V_ASN1_BIT_STRING">V_ASN1_BIT_STRING</a></tt>. See bit string documentation below for how the data and flags are used.</p>
          
            <p><span class="first-word">When</span> representing an INTEGER or ENUMERATED value, the type field is one of <tt><a href="asn1.h.html#V_ASN1_INTEGER">V_ASN1_INTEGER</a></tt>, <tt><a href="asn1.h.html#V_ASN1_NEG_INTEGER">V_ASN1_NEG_INTEGER</a></tt>, <tt><a href="asn1.h.html#V_ASN1_ENUMERATED">V_ASN1_ENUMERATED</a></tt>, or <tt><a href="asn1.h.html#V_ASN1_NEG_ENUMERATED">V_ASN1_NEG_ENUMERATED</a></tt>. See integer documentation below for details.</p>
          
            <p><span class="first-word">When</span> representing a GeneralizedTime or UTCTime value, the type field is <tt><a href="asn1.h.html#V_ASN1_GENERALIZEDTIME">V_ASN1_GENERALIZEDTIME</a></tt> or <tt><a href="asn1.h.html#V_ASN1_UTCTIME">V_ASN1_UTCTIME</a></tt>, respectively. The data contains the DER encoding of the value. For example, the UNIX epoch would be &#34;19700101000000Z&#34; for a GeneralizedTime and &#34;700101000000Z&#34; for a UTCTime.</p>
          
            <p><tt>ASN1_STRING</tt>, when stored in an <tt>ASN1_TYPE</tt>, may also represent an element with tag not directly supported by this library. See <tt>ASN1_TYPE</tt> for details.</p>
          
            <p><tt>ASN1_STRING</tt> additionally has the following typedefs: <tt>ASN1_BIT_STRING</tt>, <tt>ASN1_BMPSTRING</tt>, <tt>ASN1_ENUMERATED</tt>, <tt>ASN1_GENERALIZEDTIME</tt>, <tt>ASN1_GENERALSTRING</tt>, <tt>ASN1_IA5STRING</tt>, <tt>ASN1_INTEGER</tt>, <tt>ASN1_OCTET_STRING</tt>, <tt>ASN1_PRINTABLESTRING</tt>, <tt>ASN1_T61STRING</tt>, <tt>ASN1_TIME</tt>, <tt>ASN1_UNIVERSALSTRING</tt>, <tt>ASN1_UTCTIME</tt>, <tt>ASN1_UTF8STRING</tt>, and <tt>ASN1_VISIBLESTRING</tt>. Other than <tt>ASN1_TIME</tt>, these correspond to universal ASN.1 types. <tt>ASN1_TIME</tt> represents a CHOICE of UTCTime and GeneralizedTime, with a cutoff of 2049, as used in Section 4.1.2.5 of <a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>.</p>
          
            <p><span class="first-word">For</span> clarity, callers are encouraged to use the appropriate typedef when available. They are the same type as <tt>ASN1_STRING</tt>, so a caller may freely pass them into functions expecting <tt>ASN1_STRING</tt>, such as <tt><a href="asn1.h.html#ASN1_STRING_length">ASN1_STRING_length</a></tt>.</p>
          
            <p><span class="first-word">If</span> a function returns an <tt>ASN1_STRING</tt> where the typedef or ASN.1 structure implies constraints on the type field, callers may assume that the type field is correct. However, if a function takes an <tt>ASN1_STRING</tt> as input, callers must ensure the type field matches. These invariants are not captured by the C type system and may not be checked at runtime. For example, callers may assume the output of <tt><a href="x509.h.html#X509_get0_serialNumber">X509_get0_serialNumber</a></tt> has type <tt><a href="asn1.h.html#V_ASN1_INTEGER">V_ASN1_INTEGER</a></tt> or <tt><a href="asn1.h.html#V_ASN1_NEG_INTEGER">V_ASN1_NEG_INTEGER</a></tt>. Callers must not pass a string of type <tt><a href="asn1.h.html#V_ASN1_OCTET_STRING">V_ASN1_OCTET_STRING</a></tt> to <tt><a href="x509.h.html#X509_set_serialNumber">X509_set_serialNumber</a></tt>. Doing so may break invariants on the <tt>X509</tt> object and break the <tt><a href="x509.h.html#X509_get0_serialNumber">X509_get0_serialNumber</a></tt> invariant.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/445):</span> This is very unfriendly. Getting the type field wrong should not cause memory errors, but it may do strange things. We should add runtime checks to anything that consumes <tt>ASN1_STRING</tt>s from the caller.</p>
          
          <pre>struct asn1_string_st {
  int length;
  int type;
  unsigned char *data;
  long flags;
};</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_FLAG_BITS_LEFT">
          
            <p><span class="first-word">ASN1_STRING_FLAG_BITS_LEFT</span> indicates, in a BIT STRING <tt>ASN1_STRING</tt>, that flags &amp; 0x7 contains the number of padding bits added to the BIT STRING value. When not set, all trailing zero bits in the last byte are implicitly treated as padding. This behavior is deprecated and should not be used.</p>
          
          <pre>#define ASN1_STRING_FLAG_BITS_LEFT 0x08</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_type_new">
          
            <p><span class="first-word">ASN1_STRING_type_new</span> returns a newly-allocated empty <tt>ASN1_STRING</tt> object of type <tt>type</tt>, or NULL on error.</p>
          
          <pre>OPENSSL_EXPORT ASN1_STRING *ASN1_STRING_type_new(int type);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_new">
          
            <p><span class="first-word">ASN1_STRING_new</span> returns a newly-allocated empty <tt>ASN1_STRING</tt> object with an arbitrary type. Prefer one of the type-specific constructors, such as <tt><a href="asn1.h.html#ASN1_OCTET_STRING_new">ASN1_OCTET_STRING_new</a></tt>, or <tt><a href="asn1.h.html#ASN1_STRING_type_new">ASN1_STRING_type_new</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT ASN1_STRING *ASN1_STRING_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_free">
          
            <p><span class="first-word">ASN1_STRING_free</span> releases memory associated with <tt>str</tt>.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_STRING_free(ASN1_STRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_clear_free">
          
            <p><span class="first-word">ASN1_STRING_clear_free</span> releases memory associated with <tt>str</tt>.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_STRING_clear_free(ASN1_STRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_copy">
          
            <p><span class="first-word">ASN1_STRING_copy</span> sets <tt>dst</tt> to a copy of <tt>str</tt>. It returns one on success and zero on error.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_STRING_copy(ASN1_STRING *dst, const ASN1_STRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_dup">
          
            <p><span class="first-word">ASN1_STRING_dup</span> returns a newly-allocated copy of <tt>str</tt>, or NULL on error.</p>
          
          <pre>OPENSSL_EXPORT ASN1_STRING *ASN1_STRING_dup(const ASN1_STRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_type">
          
            <p><span class="first-word">ASN1_STRING_type</span> returns the type of <tt>str</tt>. This value will be one of the <tt>V_ASN1_*</tt> constants.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_STRING_type(const ASN1_STRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_get0_data">
          
            <p><span class="first-word">ASN1_STRING_get0_data</span> returns a pointer to <tt>str</tt>&#39;s contents. Callers should use <tt><a href="asn1.h.html#ASN1_STRING_length">ASN1_STRING_length</a></tt> to determine the length of the string. The string may have embedded NUL bytes and may not be NUL-terminated.</p>
          
          <pre>OPENSSL_EXPORT const unsigned char *ASN1_STRING_get0_data(
    const ASN1_STRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_data">
          
            <p><span class="first-word">ASN1_STRING_data</span> returns a mutable pointer to <tt>str</tt>&#39;s contents. Callers should use <tt><a href="asn1.h.html#ASN1_STRING_length">ASN1_STRING_length</a></tt> to determine the length of the string. The string may have embedded NUL bytes and may not be NUL-terminated.</p>
          
            <p><span class="first-word">Prefer</span> <tt><a href="asn1.h.html#ASN1_STRING_get0_data">ASN1_STRING_get0_data</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT unsigned char *ASN1_STRING_data(ASN1_STRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_length">
          
            <p><span class="first-word">ASN1_STRING_length</span> returns the length of <tt>str</tt>, in bytes.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_STRING_length(const ASN1_STRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_cmp">
          
            <p><span class="first-word">ASN1_STRING_cmp</span> compares <tt>a</tt> and <tt>b</tt>&#39;s type and contents. It returns an integer equal to, less than, or greater than zero if <tt>a</tt> is equal to, less than, or greater than <tt>b</tt>, respectively. This function compares by length, then data, then type. Note the data compared is the <tt>ASN1_STRING</tt> internal representation and the type order is arbitrary. While this comparison is suitable for sorting, callers should not rely on the exact order when <tt>a</tt> and <tt>b</tt> are different types.</p>
          
            <p><span class="first-word">Note</span> that, if <tt>a</tt> and <tt>b</tt> are INTEGERs, this comparison does not order the values numerically. For a numerical comparison, use <tt><a href="asn1.h.html#ASN1_INTEGER_cmp">ASN1_INTEGER_cmp</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_STRING_cmp(const ASN1_STRING *a, const ASN1_STRING *b);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_set">
          
            <p><span class="first-word">ASN1_STRING_set</span> sets the contents of <tt>str</tt> to a copy of <tt>len</tt> bytes from <tt>data</tt>. It returns one on success and zero on error. If <tt>data</tt> is NULL, it updates the length and allocates the buffer as needed, but does not initialize the contents.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_STRING_set(ASN1_STRING *str, const void *data,
                                   ossl_ssize_t len);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_set0">
          
            <p><span class="first-word">ASN1_STRING_set0</span> sets the contents of <tt>str</tt> to <tt>len</tt> bytes from <tt>data</tt>. It takes ownership of <tt>data</tt>, which must have been allocated with <tt><a href="mem.h.html#OPENSSL_malloc">OPENSSL_malloc</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_STRING_set0(ASN1_STRING *str, void *data, int len);</pre>
          </div>
        
          <div class="decl" id="ASN1_BMPSTRING_new">
          
            <p>The following functions call <tt><a href="asn1.h.html#ASN1_STRING_type_new">ASN1_STRING_type_new</a></tt> with the corresponding <tt>V_ASN1_*</tt> constant.</p>
          
          <pre>OPENSSL_EXPORT ASN1_BMPSTRING *ASN1_BMPSTRING_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_GENERALSTRING_new">
          
          <pre>OPENSSL_EXPORT ASN1_GENERALSTRING *ASN1_GENERALSTRING_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_IA5STRING_new">
          
          <pre>OPENSSL_EXPORT ASN1_IA5STRING *ASN1_IA5STRING_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_OCTET_STRING_new">
          
          <pre>OPENSSL_EXPORT ASN1_OCTET_STRING *ASN1_OCTET_STRING_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_PRINTABLESTRING_new">
          
          <pre>OPENSSL_EXPORT ASN1_PRINTABLESTRING *ASN1_PRINTABLESTRING_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_T61STRING_new">
          
          <pre>OPENSSL_EXPORT ASN1_T61STRING *ASN1_T61STRING_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_UNIVERSALSTRING_new">
          
          <pre>OPENSSL_EXPORT ASN1_UNIVERSALSTRING *ASN1_UNIVERSALSTRING_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_UTF8STRING_new">
          
          <pre>OPENSSL_EXPORT ASN1_UTF8STRING *ASN1_UTF8STRING_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_VISIBLESTRING_new">
          
          <pre>OPENSSL_EXPORT ASN1_VISIBLESTRING *ASN1_VISIBLESTRING_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_BMPSTRING_free">
          
            <p>The following functions call <tt><a href="asn1.h.html#ASN1_STRING_free">ASN1_STRING_free</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_BMPSTRING_free(ASN1_BMPSTRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_GENERALSTRING_free">
          
          <pre>OPENSSL_EXPORT void ASN1_GENERALSTRING_free(ASN1_GENERALSTRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_IA5STRING_free">
          
          <pre>OPENSSL_EXPORT void ASN1_IA5STRING_free(ASN1_IA5STRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_OCTET_STRING_free">
          
          <pre>OPENSSL_EXPORT void ASN1_OCTET_STRING_free(ASN1_OCTET_STRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_PRINTABLESTRING_free">
          
          <pre>OPENSSL_EXPORT void ASN1_PRINTABLESTRING_free(ASN1_PRINTABLESTRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_T61STRING_free">
          
          <pre>OPENSSL_EXPORT void ASN1_T61STRING_free(ASN1_T61STRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_UNIVERSALSTRING_free">
          
          <pre>OPENSSL_EXPORT void ASN1_UNIVERSALSTRING_free(ASN1_UNIVERSALSTRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_UTF8STRING_free">
          
          <pre>OPENSSL_EXPORT void ASN1_UTF8STRING_free(ASN1_UTF8STRING *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_VISIBLESTRING_free">
          
          <pre>OPENSSL_EXPORT void ASN1_VISIBLESTRING_free(ASN1_VISIBLESTRING *str);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_BMPSTRING">
          
            <p>The following functions parse up to <tt>len</tt> bytes from <tt>*inp</tt> as a DER-encoded ASN.1 value of the corresponding type, as described in <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
          <pre>OPENSSL_EXPORT ASN1_BMPSTRING *d2i_ASN1_BMPSTRING(ASN1_BMPSTRING **out,
                                                  const uint8_t **inp,
                                                  long len);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_GENERALSTRING">
          
          <pre>OPENSSL_EXPORT ASN1_GENERALSTRING *d2i_ASN1_GENERALSTRING(
    ASN1_GENERALSTRING **out, const uint8_t **inp, long len);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_IA5STRING">
          
          <pre>OPENSSL_EXPORT ASN1_IA5STRING *d2i_ASN1_IA5STRING(ASN1_IA5STRING **out,
                                                  const uint8_t **inp,
                                                  long len);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_OCTET_STRING">
          
          <pre>OPENSSL_EXPORT ASN1_OCTET_STRING *d2i_ASN1_OCTET_STRING(ASN1_OCTET_STRING **out,
                                                        const uint8_t **inp,
                                                        long len);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_PRINTABLESTRING">
          
          <pre>OPENSSL_EXPORT ASN1_PRINTABLESTRING *d2i_ASN1_PRINTABLESTRING(
    ASN1_PRINTABLESTRING **out, const uint8_t **inp, long len);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_T61STRING">
          
          <pre>OPENSSL_EXPORT ASN1_T61STRING *d2i_ASN1_T61STRING(ASN1_T61STRING **out,
                                                  const uint8_t **inp,
                                                  long len);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_UNIVERSALSTRING">
          
          <pre>OPENSSL_EXPORT ASN1_UNIVERSALSTRING *d2i_ASN1_UNIVERSALSTRING(
    ASN1_UNIVERSALSTRING **out, const uint8_t **inp, long len);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_UTF8STRING">
          
          <pre>OPENSSL_EXPORT ASN1_UTF8STRING *d2i_ASN1_UTF8STRING(ASN1_UTF8STRING **out,
                                                    const uint8_t **inp,
                                                    long len);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_VISIBLESTRING">
          
          <pre>OPENSSL_EXPORT ASN1_VISIBLESTRING *d2i_ASN1_VISIBLESTRING(
    ASN1_VISIBLESTRING **out, const uint8_t **inp, long len);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_BMPSTRING">
          
            <p>The following functions marshal <tt>in</tt> as a DER-encoded ASN.1 value of the corresponding type, as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_BMPSTRING(const ASN1_BMPSTRING *in, uint8_t **outp);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_GENERALSTRING">
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_GENERALSTRING(const ASN1_GENERALSTRING *in,
                                          uint8_t **outp);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_IA5STRING">
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_IA5STRING(const ASN1_IA5STRING *in, uint8_t **outp);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_OCTET_STRING">
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_OCTET_STRING(const ASN1_OCTET_STRING *in,
                                         uint8_t **outp);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_PRINTABLESTRING">
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_PRINTABLESTRING(const ASN1_PRINTABLESTRING *in,
                                            uint8_t **outp);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_T61STRING">
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_T61STRING(const ASN1_T61STRING *in, uint8_t **outp);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_UNIVERSALSTRING">
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_UNIVERSALSTRING(const ASN1_UNIVERSALSTRING *in,
                                            uint8_t **outp);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_UTF8STRING">
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_UTF8STRING(const ASN1_UTF8STRING *in,
                                       uint8_t **outp);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_VISIBLESTRING">
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_VISIBLESTRING(const ASN1_VISIBLESTRING *in,
                                          uint8_t **outp);</pre>
          </div>
        
          <div class="decl" >
          
            <p>The following <tt>ASN1_ITEM</tt>s have the ASN.1 type referred to in their name and C type <tt>ASN1_STRING*</tt>. The C type may also be written as the corresponding typedef.</p>
          
          <pre>DECLARE_ASN1_ITEM(ASN1_BMPSTRING)
DECLARE_ASN1_ITEM(ASN1_GENERALSTRING)
DECLARE_ASN1_ITEM(ASN1_IA5STRING)
DECLARE_ASN1_ITEM(ASN1_OCTET_STRING)
DECLARE_ASN1_ITEM(ASN1_PRINTABLESTRING)
DECLARE_ASN1_ITEM(ASN1_T61STRING)
DECLARE_ASN1_ITEM(ASN1_UNIVERSALSTRING)
DECLARE_ASN1_ITEM(ASN1_UTF8STRING)
DECLARE_ASN1_ITEM(ASN1_VISIBLESTRING)</pre>
          </div>
        
          <div class="decl" id="ASN1_OCTET_STRING_dup">
          
            <p><span class="first-word">ASN1_OCTET_STRING_dup</span> calls <tt><a href="asn1.h.html#ASN1_STRING_dup">ASN1_STRING_dup</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT ASN1_OCTET_STRING *ASN1_OCTET_STRING_dup(
    const ASN1_OCTET_STRING *a);</pre>
          </div>
        
          <div class="decl" id="ASN1_OCTET_STRING_cmp">
          
            <p><span class="first-word">ASN1_OCTET_STRING_cmp</span> calls <tt><a href="asn1.h.html#ASN1_STRING_cmp">ASN1_STRING_cmp</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_OCTET_STRING_cmp(const ASN1_OCTET_STRING *a,
                                         const ASN1_OCTET_STRING *b);</pre>
          </div>
        
          <div class="decl" id="ASN1_OCTET_STRING_set">
          
            <p><span class="first-word">ASN1_OCTET_STRING_set</span> calls <tt><a href="asn1.h.html#ASN1_STRING_set">ASN1_STRING_set</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_OCTET_STRING_set(ASN1_OCTET_STRING *str,
                                         const unsigned char *data, int len);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_to_UTF8">
          
            <p><span class="first-word">ASN1_STRING_to_UTF8</span> converts <tt>in</tt> to UTF-8. On success, sets <tt>*out</tt> to a newly-allocated buffer containing the resulting string and returns the length of the string. The caller must call <tt><a href="mem.h.html#OPENSSL_free">OPENSSL_free</a></tt> to release <tt>*out</tt> when done. On error, it returns a negative number.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_STRING_to_UTF8(unsigned char **out,
                                       const ASN1_STRING *in);</pre>
          </div>
        
          <div class="decl" id="MBSTRING_FLAG">
          
            <p>The following formats define encodings for use with functions like <tt><a href="asn1.h.html#ASN1_mbstring_copy">ASN1_mbstring_copy</a></tt>. Note <tt><a href="asn1.h.html#MBSTRING_ASC">MBSTRING_ASC</a></tt> refers to Latin-1, not ASCII.</p>
          
          <pre>#define MBSTRING_FLAG 0x1000</pre>
          </div>
        
          <div class="decl" id="MBSTRING_UTF8">
          
          <pre>#define MBSTRING_UTF8 (MBSTRING_FLAG)</pre>
          </div>
        
          <div class="decl" id="MBSTRING_ASC">
          
          <pre>#define MBSTRING_ASC (MBSTRING_FLAG | 1)</pre>
          </div>
        
          <div class="decl" id="MBSTRING_BMP">
          
          <pre>#define MBSTRING_BMP (MBSTRING_FLAG | 2)</pre>
          </div>
        
          <div class="decl" id="MBSTRING_UNIV">
          
          <pre>#define MBSTRING_UNIV (MBSTRING_FLAG | 4)</pre>
          </div>
        
          <div class="decl" id="DIRSTRING_TYPE">
          
            <p><span class="first-word">DIRSTRING_TYPE</span> contains the valid string types in an X.509 DirectoryString.</p>
          
          <pre>#define DIRSTRING_TYPE                                            \
  (B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | B_ASN1_BMPSTRING | \
   B_ASN1_UTF8STRING)</pre>
          </div>
        
          <div class="decl" id="PKCS9STRING_TYPE">
          
            <p><span class="first-word">PKCS9STRING_TYPE</span> contains the valid string types in a PKCS9String.</p>
          
          <pre>#define PKCS9STRING_TYPE (DIRSTRING_TYPE | B_ASN1_IA5STRING)</pre>
          </div>
        
          <div class="decl" id="ASN1_mbstring_copy">
          
            <p><span class="first-word">ASN1_mbstring_copy</span> converts <tt>len</tt> bytes from <tt>in</tt> to an ASN.1 string. If <tt>len</tt> is -1, <tt>in</tt> must be NUL-terminated and the length is determined by <tt>strlen</tt>. <tt>in</tt> is decoded according to <tt>inform</tt>, which must be one of <tt>MBSTRING_*</tt>. <tt>mask</tt> determines the set of valid output types and is a bitmask containing a subset of <tt><a href="asn1.h.html#B_ASN1_PRINTABLESTRING">B_ASN1_PRINTABLESTRING</a></tt>, <tt><a href="asn1.h.html#B_ASN1_IA5STRING">B_ASN1_IA5STRING</a></tt>, <tt><a href="asn1.h.html#B_ASN1_T61STRING">B_ASN1_T61STRING</a></tt>, <tt><a href="asn1.h.html#B_ASN1_BMPSTRING">B_ASN1_BMPSTRING</a></tt>, <tt><a href="asn1.h.html#B_ASN1_UNIVERSALSTRING">B_ASN1_UNIVERSALSTRING</a></tt>, and <tt><a href="asn1.h.html#B_ASN1_UTF8STRING">B_ASN1_UTF8STRING</a></tt>, in that preference order. This function chooses the first output type in <tt>mask</tt> which can represent <tt>in</tt>. It interprets T61String as Latin-1, rather than T.61.</p>
          
            <p><span class="first-word">If</span> <tt>mask</tt> is zero, <tt><a href="asn1.h.html#DIRSTRING_TYPE">DIRSTRING_TYPE</a></tt> is used by default.</p>
          
            <p><span class="first-word">On</span> success, this function returns the <tt>V_ASN1_*</tt> constant corresponding to the selected output type and, if <tt>out</tt> and <tt>*out</tt> are both non-NULL, updates the object at <tt>*out</tt> with the result. If <tt>out</tt> is non-NULL and <tt>*out</tt> is NULL, it instead sets <tt>*out</tt> to a newly-allocated <tt>ASN1_STRING</tt> containing the result. If <tt>out</tt> is NULL, it returns the selected output type without constructing an <tt>ASN1_STRING</tt>. On error, this function returns -1.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_mbstring_copy(ASN1_STRING **out, const uint8_t *in,
                                      ossl_ssize_t len, int inform,
                                      unsigned long mask);</pre>
          </div>
        
          <div class="decl" id="ASN1_mbstring_ncopy">
          
            <p><span class="first-word">ASN1_mbstring_ncopy</span> behaves like <tt><a href="asn1.h.html#ASN1_mbstring_copy">ASN1_mbstring_copy</a></tt> but returns an error if the input is less than <tt>minsize</tt> or greater than <tt>maxsize</tt> codepoints long. A <tt>maxsize</tt> value of zero is ignored. Note the sizes are measured in codepoints, not output bytes.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_mbstring_ncopy(ASN1_STRING **out, const uint8_t *in,
                                       ossl_ssize_t len, int inform,
                                       unsigned long mask, ossl_ssize_t minsize,
                                       ossl_ssize_t maxsize);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_set_by_NID">
          
            <p><span class="first-word">ASN1_STRING_set_by_NID</span> behaves like <tt><a href="asn1.h.html#ASN1_mbstring_ncopy">ASN1_mbstring_ncopy</a></tt>, but determines <tt>mask</tt>, <tt>minsize</tt>, and <tt>maxsize</tt> based on <tt>nid</tt>. When <tt>nid</tt> is a recognized X.509 attribute type, it will pick a suitable ASN.1 string type and bounds. For most attribute types, it preferentially chooses UTF8String. If <tt>nid</tt> is unrecognized, it uses UTF8String by default.</p>
          
            <p><span class="first-word">Slightly</span> unlike <tt><a href="asn1.h.html#ASN1_mbstring_ncopy">ASN1_mbstring_ncopy</a></tt>, this function interprets <tt>out</tt> and returns its result as follows: If <tt>out</tt> is NULL, it returns a newly-allocated <tt>ASN1_STRING</tt> containing the result. If <tt>out</tt> is non-NULL and <tt>*out</tt> is NULL, it additionally sets <tt>*out</tt> to the result. If both <tt>out</tt> and <tt>*out</tt> are non-NULL, it instead updates the object at <tt>*out</tt> and returns <tt>*out</tt>. In all cases, it returns NULL on error.</p>
          
            <p><span class="first-word">This</span> function supports the following NIDs: <tt>NID_countryName</tt>, <tt>NID_dnQualifier</tt>, <tt>NID_domainComponent</tt>, <tt>NID_friendlyName</tt>, <tt>NID_givenName</tt>, <tt>NID_initials</tt>, <tt>NID_localityName</tt>, <tt>NID_ms_csp_name</tt>, <tt>NID_name</tt>, <tt>NID_organizationalUnitName</tt>, <tt>NID_organizationName</tt>, <tt>NID_pkcs9_challengePassword</tt>, <tt>NID_pkcs9_emailAddress</tt>, <tt>NID_pkcs9_unstructuredAddress</tt>, <tt>NID_pkcs9_unstructuredName</tt>, <tt>NID_serialNumber</tt>, <tt>NID_stateOrProvinceName</tt>, and <tt>NID_surname</tt>. Additional NIDs may be registered with <tt><a href="asn1.h.html#ASN1_STRING_set_by_NID">ASN1_STRING_set_by_NID</a></tt>, but it is recommended to call <tt><a href="asn1.h.html#ASN1_mbstring_ncopy">ASN1_mbstring_ncopy</a></tt> directly instead.</p>
          
          <pre>OPENSSL_EXPORT ASN1_STRING *ASN1_STRING_set_by_NID(ASN1_STRING **out,
                                                   const unsigned char *in,
                                                   ossl_ssize_t len, int inform,
                                                   int nid);</pre>
          </div>
        
          <div class="decl" id="STABLE_NO_MASK">
          
            <p><span class="first-word">STABLE_NO_MASK</span> causes <tt><a href="asn1.h.html#ASN1_STRING_TABLE_add">ASN1_STRING_TABLE_add</a></tt> to allow types other than UTF8String.</p>
          
          <pre>#define STABLE_NO_MASK 0x02</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_TABLE_add">
          
            <p><span class="first-word">ASN1_STRING_TABLE_add</span> registers the corresponding parameters with <tt>nid</tt>, for use with <tt><a href="asn1.h.html#ASN1_STRING_set_by_NID">ASN1_STRING_set_by_NID</a></tt>. It returns one on success and zero on error. It is an error to call this function if <tt>nid</tt> is a built-in NID, or was already registered by a previous call.</p>
          
            <p><span class="first-word">WARNING:</span> This function affects global state in the library. If two libraries in the same address space register information for the same OID, one call will fail. Prefer directly passing the desired parametrs to <tt><a href="asn1.h.html#ASN1_mbstring_copy">ASN1_mbstring_copy</a></tt> or <tt><a href="asn1.h.html#ASN1_mbstring_ncopy">ASN1_mbstring_ncopy</a></tt> instead.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_STRING_TABLE_add(int nid, long minsize, long maxsize,
                                         unsigned long mask,
                                         unsigned long flags);</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="Multi-strings">
        
          <div class="sectionpreamble">
          <p>Multi-strings.</p><p>A multi-string, or &#34;MSTRING&#34;, is an <tt>ASN1_STRING</tt> that represents a CHOICE of several string or string-like types, such as X.509&#39;s DirectoryString. The <tt>ASN1_STRING</tt>&#39;s type field determines which type is used.</p><p>Multi-string types are associated with a bitmask, using the <tt>B_ASN1_*</tt> constants, which defines which types are valid.</p>
          </div>
        

        
          <div class="decl" id="B_ASN1_DIRECTORYSTRING">
          
            <p><span class="first-word">B_ASN1_DIRECTORYSTRING</span> is a bitmask of types allowed in an X.509 DirectoryString (<a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>).</p>
          
          <pre>#define B_ASN1_DIRECTORYSTRING                                        \
  (B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING | B_ASN1_BMPSTRING | \
   B_ASN1_UNIVERSALSTRING | B_ASN1_UTF8STRING)</pre>
          </div>
        
          <div class="decl" id="DIRECTORYSTRING_new">
          
            <p><span class="first-word">DIRECTORYSTRING_new</span> returns a newly-allocated <tt>ASN1_STRING</tt> with type -1, or NULL on error. The resulting <tt>ASN1_STRING</tt> is not a valid X.509 DirectoryString until initialized with a value.</p>
          
          <pre>OPENSSL_EXPORT ASN1_STRING *DIRECTORYSTRING_new(void);</pre>
          </div>
        
          <div class="decl" id="DIRECTORYSTRING_free">
          
            <p><span class="first-word">DIRECTORYSTRING_free</span> calls <tt><a href="asn1.h.html#ASN1_STRING_free">ASN1_STRING_free</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT void DIRECTORYSTRING_free(ASN1_STRING *str);</pre>
          </div>
        
          <div class="decl" id="d2i_DIRECTORYSTRING">
          
            <p><span class="first-word">d2i_DIRECTORYSTRING</span> parses up to <tt>len</tt> bytes from <tt>*inp</tt> as a DER-encoded X.509 DirectoryString (<a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>), as described in <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/449):</span> DirectoryString&#39;s non-empty string requirement is not currently enforced.</p>
          
          <pre>OPENSSL_EXPORT ASN1_STRING *d2i_DIRECTORYSTRING(ASN1_STRING **out,
                                                const uint8_t **inp, long len);</pre>
          </div>
        
          <div class="decl" id="i2d_DIRECTORYSTRING">
          
            <p><span class="first-word">i2d_DIRECTORYSTRING</span> marshals <tt>in</tt> as a DER-encoded X.509 DirectoryString (<a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>), as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_DIRECTORYSTRING(const ASN1_STRING *in, uint8_t **outp);</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">DIRECTORYSTRING</span> is an <tt>ASN1_ITEM</tt> whose ASN.1 type is X.509 DirectoryString (<a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>) and C type is <tt>ASN1_STRING*</tt>.</p>
          
          <pre>DECLARE_ASN1_ITEM(DIRECTORYSTRING)</pre>
          </div>
        
          <div class="decl" id="B_ASN1_DISPLAYTEXT">
          
            <p><span class="first-word">B_ASN1_DISPLAYTEXT</span> is a bitmask of types allowed in an X.509 DisplayText (<a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>).</p>
          
          <pre>#define B_ASN1_DISPLAYTEXT                                      \
  (B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING | B_ASN1_BMPSTRING | \
   B_ASN1_UTF8STRING)</pre>
          </div>
        
          <div class="decl" id="DISPLAYTEXT_new">
          
            <p><span class="first-word">DISPLAYTEXT_new</span> returns a newly-allocated <tt>ASN1_STRING</tt> with type -1, or NULL on error. The resulting <tt>ASN1_STRING</tt> is not a valid X.509 DisplayText until initialized with a value.</p>
          
          <pre>OPENSSL_EXPORT ASN1_STRING *DISPLAYTEXT_new(void);</pre>
          </div>
        
          <div class="decl" id="DISPLAYTEXT_free">
          
            <p><span class="first-word">DISPLAYTEXT_free</span> calls <tt><a href="asn1.h.html#ASN1_STRING_free">ASN1_STRING_free</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT void DISPLAYTEXT_free(ASN1_STRING *str);</pre>
          </div>
        
          <div class="decl" id="d2i_DISPLAYTEXT">
          
            <p><span class="first-word">d2i_DISPLAYTEXT</span> parses up to <tt>len</tt> bytes from <tt>*inp</tt> as a DER-encoded X.509 DisplayText (<a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>), as described in <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/449):</span> DisplayText&#39;s size limits are not currently enforced.</p>
          
          <pre>OPENSSL_EXPORT ASN1_STRING *d2i_DISPLAYTEXT(ASN1_STRING **out,
                                            const uint8_t **inp, long len);</pre>
          </div>
        
          <div class="decl" id="i2d_DISPLAYTEXT">
          
            <p><span class="first-word">i2d_DISPLAYTEXT</span> marshals <tt>in</tt> as a DER-encoded X.509 DisplayText (<a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>), as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_DISPLAYTEXT(const ASN1_STRING *in, uint8_t **outp);</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">DISPLAYTEXT</span> is an <tt>ASN1_ITEM</tt> whose ASN.1 type is X.509 DisplayText (<a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>) and C type is <tt>ASN1_STRING*</tt>.</p>
          
          <pre>DECLARE_ASN1_ITEM(DISPLAYTEXT)</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="Bit-strings">
        
          <div class="sectionpreamble">
          <p>Bit strings.</p><p>An ASN.1 BIT STRING type represents a string of bits. The string may not necessarily be a whole number of bytes. BIT STRINGs occur in ASN.1 structures in several forms:</p><p>Some BIT STRINGs represent a bitmask of named bits, such as the X.509 key usage extension in <a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>, section 4.2.1.3. For such bit strings, DER imposes an additional restriction that trailing zero bits are removed. Some functions like <tt><a href="asn1.h.html#ASN1_BIT_STRING_set_bit">ASN1_BIT_STRING_set_bit</a></tt> help in maintaining this.</p><p>Other BIT STRINGs are arbitrary strings of bits used as identifiers and do not have this constraint, such as the X.509 issuerUniqueID field.</p><p>Finally, some structures use BIT STRINGs as a container for byte strings. For example, the signatureValue field in X.509 and the subjectPublicKey field in SubjectPublicKeyInfo are defined as BIT STRINGs with a value specific to the AlgorithmIdentifier. While some unknown algorithm could choose to store arbitrary bit strings, all supported algorithms use a byte string, with bit order matching the DER encoding. Callers interpreting a BIT STRING as a byte string should use <tt><a href="asn1.h.html#ASN1_BIT_STRING_num_bytes">ASN1_BIT_STRING_num_bytes</a></tt> instead of <tt><a href="asn1.h.html#ASN1_STRING_length">ASN1_STRING_length</a></tt> and reject bit strings that are not a whole number of bytes.</p><p>This library represents BIT STRINGs as <tt>ASN1_STRING</tt>s with type <tt><a href="asn1.h.html#V_ASN1_BIT_STRING">V_ASN1_BIT_STRING</a></tt>. The data contains the encoded form of the BIT STRING, including any padding bits added to round to a whole number of bytes, but excluding the leading byte containing the number of padding bits. If <tt><a href="asn1.h.html#ASN1_STRING_FLAG_BITS_LEFT">ASN1_STRING_FLAG_BITS_LEFT</a></tt> is set, the bottom three bits contains the number of padding bits. For example, DER encodes the BIT STRING {1, 0} as {0x06, 0x80 = 0b10_000000}. The <tt>ASN1_STRING</tt> representation has data of {0x80} and flags of ASN1_STRING_FLAG_BITS_LEFT | 6. If <tt><a href="asn1.h.html#ASN1_STRING_FLAG_BITS_LEFT">ASN1_STRING_FLAG_BITS_LEFT</a></tt> is unset, trailing zero bits are implicitly removed. Callers should not rely this representation when constructing bit strings. The padding bits in the <tt>ASN1_STRING</tt> data must be zero.</p>
          </div>
        

        
          <div class="decl" id="ASN1_BIT_STRING_new">
          
            <p><span class="first-word">ASN1_BIT_STRING_new</span> calls <tt><a href="asn1.h.html#ASN1_STRING_type_new">ASN1_STRING_type_new</a></tt> with <tt><a href="asn1.h.html#V_ASN1_BIT_STRING">V_ASN1_BIT_STRING</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT ASN1_BIT_STRING *ASN1_BIT_STRING_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_BIT_STRING_free">
          
            <p><span class="first-word">ASN1_BIT_STRING_free</span> calls <tt><a href="asn1.h.html#ASN1_STRING_free">ASN1_STRING_free</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_BIT_STRING_free(ASN1_BIT_STRING *str);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_BIT_STRING">
          
            <p><span class="first-word">d2i_ASN1_BIT_STRING</span> parses up to <tt>len</tt> bytes from <tt>*inp</tt> as a DER-encoded ASN.1 BIT STRING, as described in <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
          <pre>OPENSSL_EXPORT ASN1_BIT_STRING *d2i_ASN1_BIT_STRING(ASN1_BIT_STRING **out,
                                                    const uint8_t **inp,
                                                    long len);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_BIT_STRING">
          
            <p><span class="first-word">i2d_ASN1_BIT_STRING</span> marshals <tt>in</tt> as a DER-encoded ASN.1 BIT STRING, as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_BIT_STRING(const ASN1_BIT_STRING *in,
                                       uint8_t **outp);</pre>
          </div>
        
          <div class="decl" id="c2i_ASN1_BIT_STRING">
          
            <p><span class="first-word">c2i_ASN1_BIT_STRING</span> decodes <tt>len</tt> bytes from <tt>*inp</tt> as the contents of a DER-encoded BIT STRING, excluding the tag and length. It behaves like <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt> except, on success, it always consumes all <tt>len</tt> bytes.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
          <pre>OPENSSL_EXPORT ASN1_BIT_STRING *c2i_ASN1_BIT_STRING(ASN1_BIT_STRING **out,
                                                    const uint8_t **inp,
                                                    long len);</pre>
          </div>
        
          <div class="decl" id="i2c_ASN1_BIT_STRING">
          
            <p><span class="first-word">i2c_ASN1_BIT_STRING</span> encodes <tt>in</tt> as the contents of a DER-encoded BIT STRING, excluding the tag and length. If <tt>outp</tt> is non-NULL, it writes the result to <tt>*outp</tt>, advances <tt>*outp</tt> just past the output, and returns the number of bytes written. <tt>*outp</tt> must have space available for the result. If <tt>outp</tt> is NULL, it returns the number of bytes without writing anything. On error, it returns a value &lt;= 0.</p>
          
            <p><span class="first-word">Note</span> this function differs slightly from <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>. If <tt>outp</tt> is non-NULL and <tt>*outp</tt> is NULL, it does not allocate a new buffer.</p>
          
            <p><span class="first-word">TODO(davidben):</span> This function currently returns zero on error instead of -1, but it is also mostly infallible. I&#39;ve currently documented &lt;= 0 to suggest callers work with both.</p>
          
          <pre>OPENSSL_EXPORT int i2c_ASN1_BIT_STRING(const ASN1_BIT_STRING *in,
                                       uint8_t **outp);</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">ASN1_BIT_STRING</span> is an <tt>ASN1_ITEM</tt> with ASN.1 type BIT STRING and C type <tt>ASN1_BIT_STRING*</tt>.</p>
          
          <pre>DECLARE_ASN1_ITEM(ASN1_BIT_STRING)</pre>
          </div>
        
          <div class="decl" id="ASN1_BIT_STRING_num_bytes">
          
            <p><span class="first-word">ASN1_BIT_STRING_num_bytes</span> computes the length of <tt>str</tt> in bytes. If <tt>str</tt>&#39;s bit length is a multiple of 8, it sets <tt>*out</tt> to the byte length and returns one. Otherwise, it returns zero.</p>
          
            <p><span class="first-word">This</span> function may be used with <tt><a href="asn1.h.html#ASN1_STRING_get0_data">ASN1_STRING_get0_data</a></tt> to interpret <tt>str</tt> as a byte string.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_BIT_STRING_num_bytes(const ASN1_BIT_STRING *str,
                                             size_t *out);</pre>
          </div>
        
          <div class="decl" id="ASN1_BIT_STRING_set">
          
            <p><span class="first-word">ASN1_BIT_STRING_set</span> calls <tt><a href="asn1.h.html#ASN1_STRING_set">ASN1_STRING_set</a></tt>. It leaves flags unchanged, so the caller must set the number of unused bits.</p>
          
            <p><span class="first-word">TODO(davidben):</span> Maybe it should? Wrapping a byte string in a bit string is a common use case.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_BIT_STRING_set(ASN1_BIT_STRING *str,
                                       const unsigned char *d,
                                       ossl_ssize_t length);</pre>
          </div>
        
          <div class="decl" id="ASN1_BIT_STRING_set_bit">
          
            <p><span class="first-word">ASN1_BIT_STRING_set_bit</span> sets bit <tt>n</tt> of <tt>str</tt> to one if <tt>value</tt> is non-zero and zero if <tt>value</tt> is zero, resizing <tt>str</tt> as needed. It then truncates trailing zeros in <tt>str</tt> to align with the DER represention for a bit string with named bits. It returns one on success and zero on error. <tt>n</tt> is indexed beginning from zero.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *str, int n,
                                           int value);</pre>
          </div>
        
          <div class="decl" id="ASN1_BIT_STRING_get_bit">
          
            <p><span class="first-word">ASN1_BIT_STRING_get_bit</span> returns one if bit <tt>n</tt> of <tt>a</tt> is in bounds and set, and zero otherwise. <tt>n</tt> is indexed beginning from zero.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_BIT_STRING_get_bit(const ASN1_BIT_STRING *str, int n);</pre>
          </div>
        
          <div class="decl" id="ASN1_BIT_STRING_check">
          
            <p><span class="first-word">ASN1_BIT_STRING_check</span> returns one if <tt>str</tt> only contains bits that are set in the <tt>flags_len</tt> bytes pointed by <tt>flags</tt>. Otherwise it returns zero. Bits in <tt>flags</tt> are arranged according to the DER representation, so bit 0 corresponds to the MSB of <tt>flags[0]</tt>.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_BIT_STRING_check(const ASN1_BIT_STRING *str,
                                         const unsigned char *flags,
                                         int flags_len);</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="Integers-and-enumerated-values">
        
          <div class="sectionpreamble">
          <p>Integers and enumerated values.</p><p>INTEGER and ENUMERATED values are represented as <tt>ASN1_STRING</tt>s where the data contains the big-endian encoding of the absolute value of the integer. The sign bit is encoded in the type: non-negative values have a type of <tt><a href="asn1.h.html#V_ASN1_INTEGER">V_ASN1_INTEGER</a></tt> or <tt><a href="asn1.h.html#V_ASN1_ENUMERATED">V_ASN1_ENUMERATED</a></tt>, while negative values have a type of <tt><a href="asn1.h.html#V_ASN1_NEG_INTEGER">V_ASN1_NEG_INTEGER</a></tt> or <tt><a href="asn1.h.html#V_ASN1_NEG_ENUMERATED">V_ASN1_NEG_ENUMERATED</a></tt>. Note this differs from DER&#39;s two&#39;s complement representation.</p><p>The data in the <tt>ASN1_STRING</tt> may not have leading zeros. Note this means zero is represented as the empty string. Parsing functions will never return invalid representations. If an invalid input is constructed, the marshaling functions will skip leading zeros, however other functions, such as <tt><a href="asn1.h.html#ASN1_INTEGER_cmp">ASN1_INTEGER_cmp</a></tt> or <tt><a href="asn1.h.html#ASN1_INTEGER_get">ASN1_INTEGER_get</a></tt>, may not return the correct result.</p>
          </div>
        

        
          <div class="decl" >
          
          <pre>DEFINE_STACK_OF(ASN1_INTEGER)</pre>
          </div>
        
          <div class="decl" id="ASN1_INTEGER_new">
          
            <p><span class="first-word">ASN1_INTEGER_new</span> calls <tt><a href="asn1.h.html#ASN1_STRING_type_new">ASN1_STRING_type_new</a></tt> with <tt><a href="asn1.h.html#V_ASN1_INTEGER">V_ASN1_INTEGER</a></tt>. The resulting object has value zero.</p>
          
          <pre>OPENSSL_EXPORT ASN1_INTEGER *ASN1_INTEGER_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_INTEGER_free">
          
            <p><span class="first-word">ASN1_INTEGER_free</span> calls <tt><a href="asn1.h.html#ASN1_STRING_free">ASN1_STRING_free</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_INTEGER_free(ASN1_INTEGER *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_INTEGER_dup">
          
            <p><span class="first-word">ASN1_INTEGER_dup</span> calls <tt><a href="asn1.h.html#ASN1_STRING_dup">ASN1_STRING_dup</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT ASN1_INTEGER *ASN1_INTEGER_dup(const ASN1_INTEGER *x);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_INTEGER">
          
            <p><span class="first-word">d2i_ASN1_INTEGER</span> parses up to <tt>len</tt> bytes from <tt>*inp</tt> as a DER-encoded ASN.1 INTEGER, as described in <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
          <pre>OPENSSL_EXPORT ASN1_INTEGER *d2i_ASN1_INTEGER(ASN1_INTEGER **out,
                                              const uint8_t **inp, long len);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_INTEGER">
          
            <p><span class="first-word">i2d_ASN1_INTEGER</span> marshals <tt>in</tt> as a DER-encoded ASN.1 INTEGER, as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_INTEGER(const ASN1_INTEGER *in, uint8_t **outp);</pre>
          </div>
        
          <div class="decl" id="c2i_ASN1_INTEGER">
          
            <p><span class="first-word">c2i_ASN1_INTEGER</span> decodes <tt>len</tt> bytes from <tt>*inp</tt> as the contents of a DER-encoded INTEGER, excluding the tag and length. It behaves like <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt> except, on success, it always consumes all <tt>len</tt> bytes.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts some invalid inputs, but this will be removed in the future.</p>
          
          <pre>OPENSSL_EXPORT ASN1_INTEGER *c2i_ASN1_INTEGER(ASN1_INTEGER **in,
                                              const uint8_t **outp, long len);</pre>
          </div>
        
          <div class="decl" id="i2c_ASN1_INTEGER">
          
            <p><span class="first-word">i2c_ASN1_INTEGER</span> encodes <tt>in</tt> as the contents of a DER-encoded INTEGER, excluding the tag and length. If <tt>outp</tt> is non-NULL, it writes the result to <tt>*outp</tt>, advances <tt>*outp</tt> just past the output, and returns the number of bytes written. <tt>*outp</tt> must have space available for the result. If <tt>outp</tt> is NULL, it returns the number of bytes without writing anything. On error, it returns a value &lt;= 0.</p>
          
            <p><span class="first-word">Note</span> this function differs slightly from <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>. If <tt>outp</tt> is non-NULL and <tt>*outp</tt> is NULL, it does not allocate a new buffer.</p>
          
            <p><span class="first-word">TODO(davidben):</span> This function currently returns zero on error instead of -1, but it is also mostly infallible. I&#39;ve currently documented &lt;= 0 to suggest callers work with both.</p>
          
          <pre>OPENSSL_EXPORT int i2c_ASN1_INTEGER(const ASN1_INTEGER *in, uint8_t **outp);</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">ASN1_INTEGER</span> is an <tt>ASN1_ITEM</tt> with ASN.1 type INTEGER and C type <tt>ASN1_INTEGER*</tt>.</p>
          
          <pre>DECLARE_ASN1_ITEM(ASN1_INTEGER)</pre>
          </div>
        
          <div class="decl" id="ASN1_INTEGER_set_uint64">
          
            <p><span class="first-word">ASN1_INTEGER_set_uint64</span> sets <tt>a</tt> to an INTEGER with value <tt>v</tt>. It returns one on success and zero on error.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_INTEGER_set_uint64(ASN1_INTEGER *out, uint64_t v);</pre>
          </div>
        
          <div class="decl" id="ASN1_INTEGER_set_int64">
          
            <p><span class="first-word">ASN1_INTEGER_set_int64</span> sets <tt>a</tt> to an INTEGER with value <tt>v</tt>. It returns one on success and zero on error.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_INTEGER_set_int64(ASN1_INTEGER *out, int64_t v);</pre>
          </div>
        
          <div class="decl" id="ASN1_INTEGER_get_uint64">
          
            <p><span class="first-word">ASN1_INTEGER_get_uint64</span> converts <tt>a</tt> to a <tt>uint64_t</tt>. On success, it returns one and sets <tt>*out</tt> to the result. If <tt>a</tt> did not fit or has the wrong type, it returns zero.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_INTEGER_get_uint64(uint64_t *out,
                                           const ASN1_INTEGER *a);</pre>
          </div>
        
          <div class="decl" id="ASN1_INTEGER_get_int64">
          
            <p><span class="first-word">ASN1_INTEGER_get_int64</span> converts <tt>a</tt> to a <tt>int64_t</tt>. On success, it returns one and sets <tt>*out</tt> to the result. If <tt>a</tt> did not fit or has the wrong type, it returns zero.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_INTEGER_get_int64(int64_t *out, const ASN1_INTEGER *a);</pre>
          </div>
        
          <div class="decl" id="BN_to_ASN1_INTEGER">
          
            <p><span class="first-word">BN_to_ASN1_INTEGER</span> sets <tt>ai</tt> to an INTEGER with value <tt>bn</tt> and returns <tt>ai</tt> on success or NULL or error. If <tt>ai</tt> is NULL, it returns a newly-allocated <tt>ASN1_INTEGER</tt> on success instead, which the caller must release with <tt><a href="asn1.h.html#ASN1_INTEGER_free">ASN1_INTEGER_free</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT ASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn,
                                                ASN1_INTEGER *ai);</pre>
          </div>
        
          <div class="decl" id="ASN1_INTEGER_to_BN">
          
            <p><span class="first-word">ASN1_INTEGER_to_BN</span> sets <tt>bn</tt> to the value of <tt>ai</tt> and returns <tt>bn</tt> on success or NULL or error. If <tt>bn</tt> is NULL, it returns a newly-allocated <tt>BIGNUM</tt> on success instead, which the caller must release with <tt><a href="bn.h.html#BN_free">BN_free</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT BIGNUM *ASN1_INTEGER_to_BN(const ASN1_INTEGER *ai, BIGNUM *bn);</pre>
          </div>
        
          <div class="decl" id="ASN1_INTEGER_cmp">
          
            <p><span class="first-word">ASN1_INTEGER_cmp</span> compares the values of <tt>x</tt> and <tt>y</tt>. It returns an integer equal to, less than, or greater than zero if <tt>x</tt> is equal to, less than, or greater than <tt>y</tt>, respectively.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_INTEGER_cmp(const ASN1_INTEGER *x,
                                    const ASN1_INTEGER *y);</pre>
          </div>
        
          <div class="decl" id="ASN1_ENUMERATED_new">
          
            <p><span class="first-word">ASN1_ENUMERATED_new</span> calls <tt><a href="asn1.h.html#ASN1_STRING_type_new">ASN1_STRING_type_new</a></tt> with <tt><a href="asn1.h.html#V_ASN1_ENUMERATED">V_ASN1_ENUMERATED</a></tt>. The resulting object has value zero.</p>
          
          <pre>OPENSSL_EXPORT ASN1_ENUMERATED *ASN1_ENUMERATED_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_ENUMERATED_free">
          
            <p><span class="first-word">ASN1_ENUMERATED_free</span> calls <tt><a href="asn1.h.html#ASN1_STRING_free">ASN1_STRING_free</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_ENUMERATED_free(ASN1_ENUMERATED *str);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_ENUMERATED">
          
            <p><span class="first-word">d2i_ASN1_ENUMERATED</span> parses up to <tt>len</tt> bytes from <tt>*inp</tt> as a DER-encoded ASN.1 ENUMERATED, as described in <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
          <pre>OPENSSL_EXPORT ASN1_ENUMERATED *d2i_ASN1_ENUMERATED(ASN1_ENUMERATED **out,
                                                    const uint8_t **inp,
                                                    long len);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_ENUMERATED">
          
            <p><span class="first-word">i2d_ASN1_ENUMERATED</span> marshals <tt>in</tt> as a DER-encoded ASN.1 ENUMERATED, as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_ENUMERATED(const ASN1_ENUMERATED *in,
                                       uint8_t **outp);</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">ASN1_ENUMERATED</span> is an <tt>ASN1_ITEM</tt> with ASN.1 type ENUMERATED and C type <tt>ASN1_ENUMERATED*</tt>.</p>
          
          <pre>DECLARE_ASN1_ITEM(ASN1_ENUMERATED)</pre>
          </div>
        
          <div class="decl" id="ASN1_ENUMERATED_set_uint64">
          
            <p><span class="first-word">ASN1_ENUMERATED_set_uint64</span> sets <tt>a</tt> to an ENUMERATED with value <tt>v</tt>. It returns one on success and zero on error.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_ENUMERATED_set_uint64(ASN1_ENUMERATED *out, uint64_t v);</pre>
          </div>
        
          <div class="decl" id="ASN1_ENUMERATED_set_int64">
          
            <p><span class="first-word">ASN1_ENUMERATED_set_int64</span> sets <tt>a</tt> to an ENUMERATED with value <tt>v</tt>. It returns one on success and zero on error.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_ENUMERATED_set_int64(ASN1_ENUMERATED *out, int64_t v);</pre>
          </div>
        
          <div class="decl" id="ASN1_ENUMERATED_get_uint64">
          
            <p><span class="first-word">ASN1_ENUMERATED_get_uint64</span> converts <tt>a</tt> to a <tt>uint64_t</tt>. On success, it returns one and sets <tt>*out</tt> to the result. If <tt>a</tt> did not fit or has the wrong type, it returns zero.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_ENUMERATED_get_uint64(uint64_t *out,
                                              const ASN1_ENUMERATED *a);</pre>
          </div>
        
          <div class="decl" id="ASN1_ENUMERATED_get_int64">
          
            <p><span class="first-word">ASN1_ENUMERATED_get_int64</span> converts <tt>a</tt> to a <tt>int64_t</tt>. On success, it returns one and sets <tt>*out</tt> to the result. If <tt>a</tt> did not fit or has the wrong type, it returns zero.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_ENUMERATED_get_int64(int64_t *out,
                                             const ASN1_ENUMERATED *a);</pre>
          </div>
        
          <div class="decl" id="BN_to_ASN1_ENUMERATED">
          
            <p><span class="first-word">BN_to_ASN1_ENUMERATED</span> sets <tt>ai</tt> to an ENUMERATED with value <tt>bn</tt> and returns <tt>ai</tt> on success or NULL or error. If <tt>ai</tt> is NULL, it returns a newly-allocated <tt>ASN1_ENUMERATED</tt> on success instead, which the caller must release with <tt><a href="asn1.h.html#ASN1_ENUMERATED_free">ASN1_ENUMERATED_free</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT ASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(const BIGNUM *bn,
                                                      ASN1_ENUMERATED *ai);</pre>
          </div>
        
          <div class="decl" id="ASN1_ENUMERATED_to_BN">
          
            <p><span class="first-word">ASN1_ENUMERATED_to_BN</span> sets <tt>bn</tt> to the value of <tt>ai</tt> and returns <tt>bn</tt> on success or NULL or error. If <tt>bn</tt> is NULL, it returns a newly-allocated <tt>BIGNUM</tt> on success instead, which the caller must release with <tt><a href="bn.h.html#BN_free">BN_free</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT BIGNUM *ASN1_ENUMERATED_to_BN(const ASN1_ENUMERATED *ai,
                                             BIGNUM *bn);</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="Time">
        
          <div class="sectionpreamble">
          <p>Time.</p><p>GeneralizedTime and UTCTime values are represented as <tt>ASN1_STRING</tt>s. The type field is <tt><a href="asn1.h.html#V_ASN1_GENERALIZEDTIME">V_ASN1_GENERALIZEDTIME</a></tt> or <tt><a href="asn1.h.html#V_ASN1_UTCTIME">V_ASN1_UTCTIME</a></tt>, respectively. The data field contains the DER encoding of the value. For example, the UNIX epoch would be &#34;19700101000000Z&#34; for a GeneralizedTime and &#34;700101000000Z&#34; for a UTCTime.</p><p>ASN.1 does not define how to interpret UTCTime&#39;s two-digit year. <a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a> defines it as a range from 1950 to 2049 for X.509. The library uses the <a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a> interpretation. It does not currently enforce the restrictions from BER, and the additional restrictions from <a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>, but future versions may. Callers should not rely on fractional seconds and non-UTC time zones.</p><p>The <tt>ASN1_TIME</tt> typedef is a multi-string representing the X.509 Time type, which is a CHOICE of GeneralizedTime and UTCTime, using UTCTime when the value is in range.</p>
          </div>
        

        
          <div class="decl" id="ASN1_UTCTIME_new">
          
            <p><span class="first-word">ASN1_UTCTIME_new</span> calls <tt><a href="asn1.h.html#ASN1_STRING_type_new">ASN1_STRING_type_new</a></tt> with <tt><a href="asn1.h.html#V_ASN1_UTCTIME">V_ASN1_UTCTIME</a></tt>. The resulting object contains empty contents and must be initialized to be a valid UTCTime.</p>
          
          <pre>OPENSSL_EXPORT ASN1_UTCTIME *ASN1_UTCTIME_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_UTCTIME_free">
          
            <p><span class="first-word">ASN1_UTCTIME_free</span> calls <tt><a href="asn1.h.html#ASN1_STRING_free">ASN1_STRING_free</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_UTCTIME_free(ASN1_UTCTIME *str);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_UTCTIME">
          
            <p><span class="first-word">d2i_ASN1_UTCTIME</span> parses up to <tt>len</tt> bytes from <tt>*inp</tt> as a DER-encoded ASN.1 UTCTime, as described in <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
          <pre>OPENSSL_EXPORT ASN1_UTCTIME *d2i_ASN1_UTCTIME(ASN1_UTCTIME **out,
                                              const uint8_t **inp, long len);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_UTCTIME">
          
            <p><span class="first-word">i2d_ASN1_UTCTIME</span> marshals <tt>in</tt> as a DER-encoded ASN.1 UTCTime, as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_UTCTIME(const ASN1_UTCTIME *in, uint8_t **outp);</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">ASN1_UTCTIME</span> is an <tt>ASN1_ITEM</tt> with ASN.1 type UTCTime and C type <tt>ASN1_UTCTIME*</tt>.</p>
          
          <pre>DECLARE_ASN1_ITEM(ASN1_UTCTIME)</pre>
          </div>
        
          <div class="decl" id="ASN1_UTCTIME_check">
          
            <p><span class="first-word">ASN1_UTCTIME_check</span> returns one if <tt>a</tt> is a valid UTCTime and zero otherwise.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_UTCTIME_check(const ASN1_UTCTIME *a);</pre>
          </div>
        
          <div class="decl" id="ASN1_UTCTIME_set">
          
            <p><span class="first-word">ASN1_UTCTIME_set</span> represents <tt>posix_time</tt> as a UTCTime and writes the result to <tt>s</tt>. It returns <tt>s</tt> on success and NULL on error. If <tt>s</tt> is NULL, it returns a newly-allocated <tt>ASN1_UTCTIME</tt> instead.</p>
          
            <p><span class="first-word">Note</span> this function may fail if the time is out of range for UTCTime.</p>
          
          <pre>OPENSSL_EXPORT ASN1_UTCTIME *ASN1_UTCTIME_set(ASN1_UTCTIME *s,
                                              int64_t posix_time);</pre>
          </div>
        
          <div class="decl" id="ASN1_UTCTIME_adj">
          
            <p><span class="first-word">ASN1_UTCTIME_adj</span> adds <tt>offset_day</tt> days and <tt>offset_sec</tt> seconds to <tt>posix_time</tt> and writes the result to <tt>s</tt> as a UTCTime. It returns <tt>s</tt> on success and NULL on error. If <tt>s</tt> is NULL, it returns a newly-allocated <tt>ASN1_UTCTIME</tt> instead.</p>
          
            <p><span class="first-word">Note</span> this function may fail if the time overflows or is out of range for UTCTime.</p>
          
          <pre>OPENSSL_EXPORT ASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s,
                                              int64_t posix_time,
                                              int offset_day, long offset_sec);</pre>
          </div>
        
          <div class="decl" id="ASN1_UTCTIME_set_string">
          
            <p><span class="first-word">ASN1_UTCTIME_set_string</span> sets <tt>s</tt> to a UTCTime whose contents are a copy of <tt>str</tt>. It returns one on success and zero on error or if <tt>str</tt> is not a valid UTCTime.</p>
          
            <p><span class="first-word">If</span> <tt>s</tt> is NULL, this function validates <tt>str</tt> without copying it.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_UTCTIME_set_string(ASN1_UTCTIME *s, const char *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_UTCTIME_cmp_time_t">
          
            <p><span class="first-word">ASN1_UTCTIME_cmp_time_t</span> compares <tt>s</tt> to <tt>t</tt>. It returns -1 if <tt>s</tt> &lt; <tt>t</tt>, 0 if they are equal, 1 if <tt>s</tt> &gt; <tt>t</tt>, and -2 on error.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_UTCTIME_cmp_time_t(const ASN1_UTCTIME *s, time_t t);</pre>
          </div>
        
          <div class="decl" id="ASN1_GENERALIZEDTIME_new">
          
            <p><span class="first-word">ASN1_GENERALIZEDTIME_new</span> calls <tt><a href="asn1.h.html#ASN1_STRING_type_new">ASN1_STRING_type_new</a></tt> with <tt><a href="asn1.h.html#V_ASN1_GENERALIZEDTIME">V_ASN1_GENERALIZEDTIME</a></tt>. The resulting object contains empty contents and must be initialized to be a valid GeneralizedTime.</p>
          
          <pre>OPENSSL_EXPORT ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_GENERALIZEDTIME_free">
          
            <p><span class="first-word">ASN1_GENERALIZEDTIME_free</span> calls <tt><a href="asn1.h.html#ASN1_STRING_free">ASN1_STRING_free</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_GENERALIZEDTIME_free(ASN1_GENERALIZEDTIME *str);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_GENERALIZEDTIME">
          
            <p><span class="first-word">d2i_ASN1_GENERALIZEDTIME</span> parses up to <tt>len</tt> bytes from <tt>*inp</tt> as a DER-encoded ASN.1 GeneralizedTime, as described in <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
          <pre>OPENSSL_EXPORT ASN1_GENERALIZEDTIME *d2i_ASN1_GENERALIZEDTIME(
    ASN1_GENERALIZEDTIME **out, const uint8_t **inp, long len);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_GENERALIZEDTIME">
          
            <p><span class="first-word">i2d_ASN1_GENERALIZEDTIME</span> marshals <tt>in</tt> as a DER-encoded ASN.1 GeneralizedTime, as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_GENERALIZEDTIME(const ASN1_GENERALIZEDTIME *in,
                                            uint8_t **outp);</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">ASN1_GENERALIZEDTIME</span> is an <tt>ASN1_ITEM</tt> with ASN.1 type GeneralizedTime and C type <tt>ASN1_GENERALIZEDTIME*</tt>.</p>
          
          <pre>DECLARE_ASN1_ITEM(ASN1_GENERALIZEDTIME)</pre>
          </div>
        
          <div class="decl" id="ASN1_GENERALIZEDTIME_check">
          
            <p><span class="first-word">ASN1_GENERALIZEDTIME_check</span> returns one if <tt>a</tt> is a valid GeneralizedTime and zero otherwise.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_GENERALIZEDTIME_check(const ASN1_GENERALIZEDTIME *a);</pre>
          </div>
        
          <div class="decl" id="ASN1_GENERALIZEDTIME_set">
          
            <p><span class="first-word">ASN1_GENERALIZEDTIME_set</span> represents <tt>posix_time</tt> as a GeneralizedTime and writes the result to <tt>s</tt>. It returns <tt>s</tt> on success and NULL on error. If <tt>s</tt> is NULL, it returns a newly-allocated <tt>ASN1_GENERALIZEDTIME</tt> instead.</p>
          
            <p><span class="first-word">Note</span> this function may fail if the time is out of range for GeneralizedTime.</p>
          
          <pre>OPENSSL_EXPORT ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_set(
    ASN1_GENERALIZEDTIME *s, int64_t posix_time);</pre>
          </div>
        
          <div class="decl" id="ASN1_GENERALIZEDTIME_adj">
          
            <p><span class="first-word">ASN1_GENERALIZEDTIME_adj</span> adds <tt>offset_day</tt> days and <tt>offset_sec</tt> seconds to <tt>posix_time</tt> and writes the result to <tt>s</tt> as a GeneralizedTime. It returns <tt>s</tt> on success and NULL on error. If <tt>s</tt> is NULL, it returns a newly-allocated <tt>ASN1_GENERALIZEDTIME</tt> instead.</p>
          
            <p><span class="first-word">Note</span> this function may fail if the time overflows or is out of range for GeneralizedTime.</p>
          
          <pre>OPENSSL_EXPORT ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_adj(
    ASN1_GENERALIZEDTIME *s, int64_t posix_time, int offset_day,
    long offset_sec);</pre>
          </div>
        
          <div class="decl" id="ASN1_GENERALIZEDTIME_set_string">
          
            <p><span class="first-word">ASN1_GENERALIZEDTIME_set_string</span> sets <tt>s</tt> to a GeneralizedTime whose contents are a copy of <tt>str</tt>. It returns one on success and zero on error or if <tt>str</tt> is not a valid GeneralizedTime.</p>
          
            <p><span class="first-word">If</span> <tt>s</tt> is NULL, this function validates <tt>str</tt> without copying it.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *s,
                                                   const char *str);</pre>
          </div>
        
          <div class="decl" id="B_ASN1_TIME">
          
            <p><span class="first-word">B_ASN1_TIME</span> is a bitmask of types allowed in an X.509 Time.</p>
          
          <pre>#define B_ASN1_TIME (B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME)</pre>
          </div>
        
          <div class="decl" id="ASN1_TIME_new">
          
            <p><span class="first-word">ASN1_TIME_new</span> returns a newly-allocated <tt>ASN1_TIME</tt> with type -1, or NULL on error. The resulting <tt>ASN1_TIME</tt> is not a valid X.509 Time until initialized with a value.</p>
          
          <pre>OPENSSL_EXPORT ASN1_TIME *ASN1_TIME_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_TIME_free">
          
            <p><span class="first-word">ASN1_TIME_free</span> releases memory associated with <tt>str</tt>.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_TIME_free(ASN1_TIME *str);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_TIME">
          
            <p><span class="first-word">d2i_ASN1_TIME</span> parses up to <tt>len</tt> bytes from <tt>*inp</tt> as a DER-encoded X.509 Time (<a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>), as described in <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
          <pre>OPENSSL_EXPORT ASN1_TIME *d2i_ASN1_TIME(ASN1_TIME **out, const uint8_t **inp,
                                        long len);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_TIME">
          
            <p><span class="first-word">i2d_ASN1_TIME</span> marshals <tt>in</tt> as a DER-encoded X.509 Time (<a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>), as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_TIME(const ASN1_TIME *in, uint8_t **outp);</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">ASN1_TIME</span> is an <tt>ASN1_ITEM</tt> whose ASN.1 type is X.509 Time (<a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>) and C type is <tt>ASN1_TIME*</tt>.</p>
          
          <pre>DECLARE_ASN1_ITEM(ASN1_TIME)</pre>
          </div>
        
          <div class="decl" id="ASN1_TIME_diff">
          
            <p><span class="first-word">ASN1_TIME_diff</span> computes <tt>to</tt> - <tt>from</tt>. On success, it sets <tt>*out_days</tt> to the difference in days, rounded towards zero, sets <tt>*out_seconds</tt> to the remainder, and returns one. On error, it returns zero.</p>
          
            <p><span class="first-word">If</span> <tt>from</tt> is before <tt>to</tt>, both outputs will be &lt;= 0, with at least one negative. If <tt>from</tt> is after <tt>to</tt>, both will be &gt;= 0, with at least one positive. If they are equal, ignoring fractional seconds, both will be zero.</p>
          
            <p><span class="first-word">Note</span> this function may fail on overflow, or if <tt>from</tt> or <tt>to</tt> cannot be decoded.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_TIME_diff(int *out_days, int *out_seconds,
                                  const ASN1_TIME *from, const ASN1_TIME *to);</pre>
          </div>
        
          <div class="decl" id="ASN1_TIME_set_posix">
          
            <p><span class="first-word">ASN1_TIME_set_posix</span> represents <tt>posix_time</tt> as a GeneralizedTime or UTCTime and writes the result to <tt>s</tt>. As in <a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>, section 4.1.2.5, it uses UTCTime when the time fits and GeneralizedTime otherwise. It returns <tt>s</tt> on success and NULL on error. If <tt>s</tt> is NULL, it returns a newly-allocated <tt>ASN1_TIME</tt> instead.</p>
          
            <p><span class="first-word">Note</span> this function may fail if the time is out of range for GeneralizedTime.</p>
          
          <pre>OPENSSL_EXPORT ASN1_TIME *ASN1_TIME_set_posix(ASN1_TIME *s, int64_t posix_time);</pre>
          </div>
        
          <div class="decl" id="ASN1_TIME_set">
          
            <p><span class="first-word">ASN1_TIME_set</span> is exactly the same as <tt><a href="asn1.h.html#ASN1_TIME_set_posix">ASN1_TIME_set_posix</a></tt> but with a time_t as input for compatibility.</p>
          
          <pre>OPENSSL_EXPORT ASN1_TIME *ASN1_TIME_set(ASN1_TIME *s, time_t time);</pre>
          </div>
        
          <div class="decl" id="ASN1_TIME_adj">
          
            <p><span class="first-word">ASN1_TIME_adj</span> adds <tt>offset_day</tt> days and <tt>offset_sec</tt> seconds to <tt>posix_time</tt> and writes the result to <tt>s</tt>. As in <a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>, section 4.1.2.5, it uses UTCTime when the time fits and GeneralizedTime otherwise. It returns <tt>s</tt> on success and NULL on error. If <tt>s</tt> is NULL, it returns a newly-allocated <tt>ASN1_GENERALIZEDTIME</tt> instead.</p>
          
            <p><span class="first-word">Note</span> this function may fail if the time overflows or is out of range for GeneralizedTime.</p>
          
          <pre>OPENSSL_EXPORT ASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s, int64_t posix_time,
                                        int offset_day, long offset_sec);</pre>
          </div>
        
          <div class="decl" id="ASN1_TIME_check">
          
            <p><span class="first-word">ASN1_TIME_check</span> returns one if <tt>t</tt> is a valid UTCTime or GeneralizedTime, and zero otherwise. <tt>t</tt>&#39;s type determines which check is performed. This function does not enforce that UTCTime was used when possible.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_TIME_check(const ASN1_TIME *t);</pre>
          </div>
        
          <div class="decl" id="ASN1_TIME_to_generalizedtime">
          
            <p><span class="first-word">ASN1_TIME_to_generalizedtime</span> converts <tt>t</tt> to a GeneralizedTime. If <tt>out</tt> is NULL, it returns a newly-allocated <tt>ASN1_GENERALIZEDTIME</tt> on success, or NULL on error. If <tt>out</tt> is non-NULL and <tt>*out</tt> is NULL, it additionally sets <tt>*out</tt> to the result. If <tt>out</tt> and <tt>*out</tt> are non-NULL, it instead updates the object pointed by <tt>*out</tt> and returns <tt>*out</tt> on success or NULL on error.</p>
          
          <pre>OPENSSL_EXPORT ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(
    const ASN1_TIME *t, ASN1_GENERALIZEDTIME **out);</pre>
          </div>
        
          <div class="decl" id="ASN1_TIME_set_string">
          
            <p><span class="first-word">ASN1_TIME_set_string</span> behaves like <tt><a href="asn1.h.html#ASN1_UTCTIME_set_string">ASN1_UTCTIME_set_string</a></tt> if <tt>str</tt> is a valid UTCTime, and <tt><a href="asn1.h.html#ASN1_GENERALIZEDTIME_set_string">ASN1_GENERALIZEDTIME_set_string</a></tt> if <tt>str</tt> is a valid GeneralizedTime. If <tt>str</tt> is neither, it returns zero.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_TIME_set_string(ASN1_TIME *s, const char *str);</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="ASN1_TIME-conversion-functions">
        
          <div class="sectionpreamble">
          <p>ASN1_TIME conversion functions.</p><p><tt>struct</tt> <tt>tm</tt> represents a calendar date: year, month, day... it is not necessarily a valid day, e.g. month 13. <tt>time_t</tt> is a typedef for the system&#39;s type that represents the seconds since the UNIX epoch. Posix time is a signed 64-bit integer which also represents the seconds since the UNIX epoch.</p>
          </div>
        

        
          <div class="decl" id="ASN1_TIME_to_tm">
          
            <p><span class="first-word">ASN1_TIME_to_tm</span> converts the ASN1 time <tt>t</tt> to the calendar day representation and writes it to <tt>out</tt>. If <tt>t</tt> is NULL, then the current time is converted. The output time is GMT. The tm_sec, tm_min, tm_hour, tm_mday, tm_mon and tm_year fields of <tt>out</tt> are set to proper values, all other fields are set to 0. If tm is NULL this function performs a format check on <tt>t</tt> only.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_TIME_to_tm(const ASN1_TIME *t, struct tm *out);</pre>
          </div>
        
          <div class="decl" id="ASN1_TIME_set_string_X509">
          
            <p><span class="first-word">ASN1_TIME_set_string_X509</span> behaves like <tt><a href="asn1.h.html#ASN1_TIME_set_string">ASN1_TIME_set_string</a></tt> except it additionally converts GeneralizedTime to UTCTime if it is in the range where UTCTime is used. See <a href="https://www.rfc-editor.org/rfc/rfc5280.html">RFC 5280</a>, section 4.1.2.5.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_TIME_set_string_X509(ASN1_TIME *s, const char *str);</pre>
          </div>
        
          <div class="decl" id="ASN1_TIME_to_time_t">
          
            <p><span class="first-word">ASN1_TIME_to_time_t</span> converts <tt>t</tt> to a time_t value in <tt>out</tt>. On success, one is returned. On failure zero is returned. This function will fail if the time can not be represented in a time_t.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_TIME_to_time_t(const ASN1_TIME *t, time_t *out);</pre>
          </div>
        
          <div class="decl" id="ASN1_TIME_to_posix">
          
            <p><span class="first-word">ASN1_TIME_to_posix</span> converts <tt>t</tt> to a POSIX time value in <tt>out</tt>. On success, one is returned. On failure zero is returned.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_TIME_to_posix(const ASN1_TIME *t, int64_t *out);</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">TODO(davidben):</span> Expand and document function prototypes generated in macros.</p>
          
          <pre></pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="NULL-values">
        
          <div class="sectionpreamble">
          <p>NULL values.</p><p>This library represents the ASN.1 NULL value by a non-NULL pointer to the opaque type <tt>ASN1_NULL</tt>. An omitted OPTIONAL ASN.1 NULL value is a NULL pointer. Unlike other pointer types, it is not necessary to free <tt>ASN1_NULL</tt> pointers, but it is safe to do so.</p>
          </div>
        

        
          <div class="decl" id="ASN1_NULL_new">
          
            <p><span class="first-word">ASN1_NULL_new</span> returns an opaque, non-NULL pointer. It is safe to call <tt><a href="asn1.h.html#ASN1_NULL_free">ASN1_NULL_free</a></tt> on the result, but not necessary.</p>
          
          <pre>OPENSSL_EXPORT ASN1_NULL *ASN1_NULL_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_NULL_free">
          
            <p><span class="first-word">ASN1_NULL_free</span> does nothing.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_NULL_free(ASN1_NULL *null);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_NULL">
          
            <p><span class="first-word">d2i_ASN1_NULL</span> parses a DER-encoded ASN.1 NULL value from up to <tt>len</tt> bytes at <tt>*inp</tt>, as described in <tt><a href="asn1.h.html#d2i_SAMPLE">d2i_SAMPLE</a></tt>.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
          <pre>OPENSSL_EXPORT ASN1_NULL *d2i_ASN1_NULL(ASN1_NULL **out, const uint8_t **inp,
                                        long len);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_NULL">
          
            <p><span class="first-word">i2d_ASN1_NULL</span> marshals <tt>in</tt> as a DER-encoded ASN.1 NULL value, as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_NULL(const ASN1_NULL *in, uint8_t **outp);</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">ASN1_NULL</span> is an <tt>ASN1_ITEM</tt> with ASN.1 type NULL and C type <tt>ASN1_NULL*</tt>.</p>
          
          <pre>DECLARE_ASN1_ITEM(ASN1_NULL)</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="Object-identifiers">
        
          <div class="sectionpreamble">
          <p>Object identifiers.</p><p>An <tt>ASN1_OBJECT</tt> represents a ASN.1 OBJECT IDENTIFIER. See also obj.h for additional functions relating to <tt>ASN1_OBJECT</tt>.</p><p>TODO(davidben): What&#39;s the relationship between asn1.h and obj.h? Most of obj.h deals with the large NID table, but then functions like <tt><a href="obj.h.html#OBJ_get0_data">OBJ_get0_data</a></tt> or <tt><a href="obj.h.html#OBJ_dup">OBJ_dup</a></tt> are general <tt>ASN1_OBJECT</tt> functions.</p>
          </div>
        

        
          <div class="decl" >
          
          <pre>DEFINE_STACK_OF(ASN1_OBJECT)</pre>
          </div>
        
          <div class="decl" id="ASN1_OBJECT_create">
          
            <p><span class="first-word">ASN1_OBJECT_create</span> returns a newly-allocated <tt>ASN1_OBJECT</tt> with <tt>len</tt> bytes from <tt>data</tt> as the encoded OID, or NULL on error. <tt>data</tt> should contain the DER-encoded identifier, excluding the tag and length.</p>
          
            <p><tt>nid</tt> should be <tt>NID_undef</tt>. Passing a NID value that does not match <tt>data</tt> will cause some functions to misbehave. <tt>sn</tt> and <tt>ln</tt> should be NULL. If non-NULL, they are stored as short and long names, respectively, but these values have no effect for <tt>ASN1_OBJECT</tt>s created through this function.</p>
          
            <p><span class="first-word">TODO(davidben):</span> Should we just ignore all those parameters? NIDs and names are only relevant for <tt>ASN1_OBJECT</tt>s in the obj.h table.</p>
          
          <pre>OPENSSL_EXPORT ASN1_OBJECT *ASN1_OBJECT_create(int nid, const uint8_t *data,
                                               size_t len, const char *sn,
                                               const char *ln);</pre>
          </div>
        
          <div class="decl" id="ASN1_OBJECT_free">
          
            <p><span class="first-word">ASN1_OBJECT_free</span> releases memory associated with <tt>a</tt>. If <tt>a</tt> is a static <tt>ASN1_OBJECT</tt>, returned from <tt><a href="obj.h.html#OBJ_nid2obj">OBJ_nid2obj</a></tt>, this function does nothing.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_OBJECT_free(ASN1_OBJECT *a);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_OBJECT">
          
            <p><span class="first-word">d2i_ASN1_OBJECT</span> parses a DER-encoded ASN.1 OBJECT IDENTIFIER from up to <tt>len</tt> bytes at <tt>*inp</tt>, as described in <tt><a href="asn1.h.html#d2i_SAMPLE">d2i_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT ASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **out,
                                            const uint8_t **inp, long len);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_OBJECT">
          
            <p><span class="first-word">i2d_ASN1_OBJECT</span> marshals <tt>in</tt> as a DER-encoded ASN.1 OBJECT IDENTIFIER, as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_OBJECT(const ASN1_OBJECT *in, uint8_t **outp);</pre>
          </div>
        
          <div class="decl" id="c2i_ASN1_OBJECT">
          
            <p><span class="first-word">c2i_ASN1_OBJECT</span> decodes <tt>len</tt> bytes from <tt>*inp</tt> as the contents of a DER-encoded OBJECT IDENTIFIER, excluding the tag and length. It behaves like <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt> except, on success, it always consumes all <tt>len</tt> bytes.</p>
          
          <pre>OPENSSL_EXPORT ASN1_OBJECT *c2i_ASN1_OBJECT(ASN1_OBJECT **out,
                                            const uint8_t **inp, long len);</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">ASN1_OBJECT</span> is an <tt>ASN1_ITEM</tt> with ASN.1 type OBJECT IDENTIFIER and C type <tt>ASN1_OBJECT*</tt>.</p>
          
          <pre>DECLARE_ASN1_ITEM(ASN1_OBJECT)</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="Arbitrary-elements">
        
          <div class="sectionpreamble">
          <p>Arbitrary elements.</p>
          </div>
        

        
          <div class="decl" id="asn1_type_st">
          
            <p>An <span class="first-word">asn1_type_st</span> (aka <tt>ASN1_TYPE</tt>) represents an arbitrary ASN.1 element, typically used for ANY types. It contains a <tt>type</tt> field and a <tt>value</tt> union dependent on <tt>type</tt>.</p>
          
            <p><span class="first-word">WARNING:</span> This struct has a complex representation. Callers must not construct <tt>ASN1_TYPE</tt> values manually. Use <tt><a href="asn1.h.html#ASN1_TYPE_set">ASN1_TYPE_set</a></tt> and <tt><a href="asn1.h.html#ASN1_TYPE_set1">ASN1_TYPE_set1</a></tt> instead. Additionally, callers performing non-trivial operations on this type are encouraged to use <tt>CBS</tt> and <tt>CBB</tt> from &lt;openssl/bytestring.h&gt;, and convert to or from <tt>ASN1_TYPE</tt> with <tt><a href="asn1.h.html#d2i_ASN1_TYPE">d2i_ASN1_TYPE</a></tt> or <tt><a href="asn1.h.html#i2d_ASN1_TYPE">i2d_ASN1_TYPE</a></tt>.</p>
          
            <p>The <tt>type</tt> field corresponds to the tag of the ASN.1 element being represented:</p>
          
            <p><span class="first-word">If</span> <tt>type</tt> is a <tt>V_ASN1_*</tt> constant for an ASN.1 string-like type, as defined by <tt>ASN1_STRING</tt>, the tag matches the constant. <tt>value</tt> contains an <tt>ASN1_STRING</tt> pointer (equivalently, one of the more specific typedefs). See <tt>ASN1_STRING</tt> for details on the representation. Unlike <tt>ASN1_STRING</tt>, <tt>ASN1_TYPE</tt> does not use the <tt><a href="asn1.h.html#V_ASN1_NEG">V_ASN1_NEG</a></tt> flag for negative INTEGER and ENUMERATE values. For a negative value, the <tt>ASN1_TYPE</tt>&#39;s <tt>type</tt> will be <tt><a href="asn1.h.html#V_ASN1_INTEGER">V_ASN1_INTEGER</a></tt> or <tt><a href="asn1.h.html#V_ASN1_ENUMERATED">V_ASN1_ENUMERATED</a></tt>, but <tt>value</tt> will an <tt>ASN1_STRING</tt> whose <tt>type</tt> is <tt><a href="asn1.h.html#V_ASN1_NEG_INTEGER">V_ASN1_NEG_INTEGER</a></tt> or <tt><a href="asn1.h.html#V_ASN1_NEG_ENUMERATED">V_ASN1_NEG_ENUMERATED</a></tt>.</p>
          
            <p><span class="first-word">If</span> <tt>type</tt> is <tt><a href="asn1.h.html#V_ASN1_OBJECT">V_ASN1_OBJECT</a></tt>, the tag is OBJECT IDENTIFIER and <tt>value</tt> contains an <tt>ASN1_OBJECT</tt> pointer.</p>
          
            <p><span class="first-word">If</span> <tt>type</tt> is <tt><a href="asn1.h.html#V_ASN1_NULL">V_ASN1_NULL</a></tt>, the tag is NULL. <tt>value</tt> contains a NULL pointer.</p>
          
            <p><span class="first-word">If</span> <tt>type</tt> is <tt><a href="asn1.h.html#V_ASN1_BOOLEAN">V_ASN1_BOOLEAN</a></tt>, the tag is BOOLEAN. <tt>value</tt> contains an <tt>ASN1_BOOLEAN</tt>.</p>
          
            <p><span class="first-word">If</span> <tt>type</tt> is <tt><a href="asn1.h.html#V_ASN1_SEQUENCE">V_ASN1_SEQUENCE</a></tt>, <tt><a href="asn1.h.html#V_ASN1_SET">V_ASN1_SET</a></tt>, or <tt><a href="asn1.h.html#V_ASN1_OTHER">V_ASN1_OTHER</a></tt>, the tag is SEQUENCE, SET, or some non-universal tag, respectively. <tt>value</tt> is an <tt>ASN1_STRING</tt> containing the entire element, including the tag and length. The <tt>ASN1_STRING</tt>&#39;s <tt>type</tt> field matches the containing <tt>ASN1_TYPE</tt>&#39;s <tt>type</tt>.</p>
          
            <p><span class="first-word">Other</span> positive values of <tt>type</tt>, up to <tt><a href="asn1.h.html#V_ASN1_MAX_UNIVERSAL">V_ASN1_MAX_UNIVERSAL</a></tt>, correspond to universal primitive tags not directly supported by this library. <tt>value</tt> is an <tt>ASN1_STRING</tt> containing the body of the element, excluding the tag and length. The <tt>ASN1_STRING</tt>&#39;s <tt>type</tt> field matches the containing <tt>ASN1_TYPE</tt>&#39;s <tt>type</tt>.</p>
          
          <pre>struct asn1_type_st {
  int type;
  union {
    char *ptr;
    ASN1_BOOLEAN boolean;
    ASN1_STRING *asn1_string;
    ASN1_OBJECT *object;
    ASN1_INTEGER *integer;
    ASN1_ENUMERATED *enumerated;
    ASN1_BIT_STRING *bit_string;
    ASN1_OCTET_STRING *octet_string;
    ASN1_PRINTABLESTRING *printablestring;
    ASN1_T61STRING *t61string;
    ASN1_IA5STRING *ia5string;
    ASN1_GENERALSTRING *generalstring;
    ASN1_BMPSTRING *bmpstring;
    ASN1_UNIVERSALSTRING *universalstring;
    ASN1_UTCTIME *utctime;
    ASN1_GENERALIZEDTIME *generalizedtime;
    ASN1_VISIBLESTRING *visiblestring;
    ASN1_UTF8STRING *utf8string;
    // set and sequence are left complete and still contain the entire element.
    ASN1_STRING *set;
    ASN1_STRING *sequence;
    ASN1_VALUE *asn1_value;
  } value;
};
DEFINE_STACK_OF(ASN1_TYPE)</pre>
          </div>
        
          <div class="decl" id="ASN1_TYPE_new">
          
            <p><span class="first-word">ASN1_TYPE_new</span> returns a newly-allocated <tt>ASN1_TYPE</tt>, or NULL on allocation failure. The resulting object has type -1 and must be initialized to be a valid ANY value.</p>
          
          <pre>OPENSSL_EXPORT ASN1_TYPE *ASN1_TYPE_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_TYPE_free">
          
            <p><span class="first-word">ASN1_TYPE_free</span> releases memory associated with <tt>a</tt>.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_TYPE_free(ASN1_TYPE *a);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_TYPE">
          
            <p><span class="first-word">d2i_ASN1_TYPE</span> parses up to <tt>len</tt> bytes from <tt>*inp</tt> as an ASN.1 value of any type, as described in <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>. Note this function only validates primitive, universal types supported by this library. Values of type <tt><a href="asn1.h.html#V_ASN1_SEQUENCE">V_ASN1_SEQUENCE</a></tt>, <tt><a href="asn1.h.html#V_ASN1_SET">V_ASN1_SET</a></tt>, <tt><a href="asn1.h.html#V_ASN1_OTHER">V_ASN1_OTHER</a></tt>, or an unsupported primitive type must be validated by the caller when interpreting.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
          <pre>OPENSSL_EXPORT ASN1_TYPE *d2i_ASN1_TYPE(ASN1_TYPE **out, const uint8_t **inp,
                                        long len);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_TYPE">
          
            <p><span class="first-word">i2d_ASN1_TYPE</span> marshals <tt>in</tt> as DER, as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_TYPE(const ASN1_TYPE *in, uint8_t **outp);</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">ASN1_ANY</span> is an <tt>ASN1_ITEM</tt> with ASN.1 type ANY and C type <tt>ASN1_TYPE*</tt>. Note the <tt>ASN1_ITEM</tt> name and C type do not match.</p>
          
          <pre>DECLARE_ASN1_ITEM(ASN1_ANY)</pre>
          </div>
        
          <div class="decl" id="ASN1_TYPE_get">
          
            <p><span class="first-word">ASN1_TYPE_get</span> returns the type of <tt>a</tt>, which will be one of the <tt>V_ASN1_*</tt> constants, or zero if <tt>a</tt> is not fully initialized.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_TYPE_get(const ASN1_TYPE *a);</pre>
          </div>
        
          <div class="decl" id="ASN1_TYPE_set">
          
            <p><span class="first-word">ASN1_TYPE_set</span> sets <tt>a</tt> to an <tt>ASN1_TYPE</tt> of type <tt>type</tt> and value <tt>value</tt>, releasing the previous contents of <tt>a</tt>.</p>
          
            <p><span class="first-word">If</span> <tt>type</tt> is <tt><a href="asn1.h.html#V_ASN1_BOOLEAN">V_ASN1_BOOLEAN</a></tt>, <tt>a</tt> is set to FALSE if <tt>value</tt> is NULL and TRUE otherwise. If setting <tt>a</tt> to TRUE, <tt>value</tt> may be an invalid pointer, such as (void*)1.</p>
          
            <p><span class="first-word">If</span> <tt>type</tt> is <tt><a href="asn1.h.html#V_ASN1_NULL">V_ASN1_NULL</a></tt>, <tt>value</tt> must be NULL.</p>
          
            <p><span class="first-word">For</span> other values of <tt>type</tt>, this function takes ownership of <tt>value</tt>, which must point to an object of the corresponding type. See <tt>ASN1_TYPE</tt> for details.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_TYPE_set(ASN1_TYPE *a, int type, void *value);</pre>
          </div>
        
          <div class="decl" id="ASN1_TYPE_set1">
          
            <p><span class="first-word">ASN1_TYPE_set1</span> behaves like <tt><a href="asn1.h.html#ASN1_TYPE_set">ASN1_TYPE_set</a></tt> except it does not take ownership of <tt>value</tt>. It returns one on success and zero on error.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_TYPE_set1(ASN1_TYPE *a, int type, const void *value);</pre>
          </div>
        
          <div class="decl" id="ASN1_TYPE_cmp">
          
            <p><span class="first-word">ASN1_TYPE_cmp</span> returns zero if <tt>a</tt> and <tt>b</tt> are equal and some non-zero value otherwise. Note this function can only be used for equality checks, not an ordering.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b);
typedef STACK_OF(ASN1_TYPE) ASN1_SEQUENCE_ANY;</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_SEQUENCE_ANY">
          
            <p><span class="first-word">d2i_ASN1_SEQUENCE_ANY</span> parses up to <tt>len</tt> bytes from <tt>*inp</tt> as a DER-encoded ASN.1 SEQUENCE OF ANY structure, as described in <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>. The resulting <tt>ASN1_SEQUENCE_ANY</tt> owns its contents and thus must be released with <tt>sk_ASN1_TYPE_pop_free</tt> and <tt><a href="asn1.h.html#ASN1_TYPE_free">ASN1_TYPE_free</a></tt>, not <tt>sk_ASN1_TYPE_free</tt>.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
          <pre>OPENSSL_EXPORT ASN1_SEQUENCE_ANY *d2i_ASN1_SEQUENCE_ANY(ASN1_SEQUENCE_ANY **out,
                                                        const uint8_t **inp,
                                                        long len);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_SEQUENCE_ANY">
          
            <p><span class="first-word">i2d_ASN1_SEQUENCE_ANY</span> marshals <tt>in</tt> as a DER-encoded SEQUENCE OF ANY structure, as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_SEQUENCE_ANY(const ASN1_SEQUENCE_ANY *in,
                                         uint8_t **outp);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_SET_ANY">
          
            <p><span class="first-word">d2i_ASN1_SET_ANY</span> parses up to <tt>len</tt> bytes from <tt>*inp</tt> as a DER-encoded ASN.1 SET OF ANY structure, as described in <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>. The resulting <tt>ASN1_SEQUENCE_ANY</tt> owns its contents and thus must be released with <tt>sk_ASN1_TYPE_pop_free</tt> and <tt><a href="asn1.h.html#ASN1_TYPE_free">ASN1_TYPE_free</a></tt>, not <tt>sk_ASN1_TYPE_free</tt>.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
          <pre>OPENSSL_EXPORT ASN1_SEQUENCE_ANY *d2i_ASN1_SET_ANY(ASN1_SEQUENCE_ANY **out,
                                                   const uint8_t **inp,
                                                   long len);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_SET_ANY">
          
            <p><span class="first-word">i2d_ASN1_SET_ANY</span> marshals <tt>in</tt> as a DER-encoded SET OF ANY structure, as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_SET_ANY(const ASN1_SEQUENCE_ANY *in,
                                    uint8_t **outp);</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="Human-readable-output">
        
          <div class="sectionpreamble">
          <p>Human-readable output.</p><p>The following functions output types in some human-readable format. These functions may be used for debugging and logging. However, the output should not be consumed programmatically. They may be ambiguous or lose information.</p>
          </div>
        

        
          <div class="decl" id="ASN1_UTCTIME_print">
          
            <p><span class="first-word">ASN1_UTCTIME_print</span> writes a human-readable representation of <tt>a</tt> to <tt>out</tt>. It returns one on success and zero on error.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_UTCTIME_print(BIO *out, const ASN1_UTCTIME *a);</pre>
          </div>
        
          <div class="decl" id="ASN1_GENERALIZEDTIME_print">
          
            <p><span class="first-word">ASN1_GENERALIZEDTIME_print</span> writes a human-readable representation of <tt>a</tt> to <tt>out</tt>. It returns one on success and zero on error.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_GENERALIZEDTIME_print(BIO *out,
                                              const ASN1_GENERALIZEDTIME *a);</pre>
          </div>
        
          <div class="decl" id="ASN1_TIME_print">
          
            <p><span class="first-word">ASN1_TIME_print</span> writes a human-readable representation of <tt>a</tt> to <tt>out</tt>. It returns one on success and zero on error.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_TIME_print(BIO *out, const ASN1_TIME *a);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_print">
          
            <p><span class="first-word">ASN1_STRING_print</span> writes a human-readable representation of <tt>str</tt> to <tt>out</tt>. It returns one on success and zero on error. Unprintable characters are replaced with &#39;.&#39;.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_STRING_print(BIO *out, const ASN1_STRING *str);</pre>
          </div>
        
          <div class="decl" >
          
            <p>The following flags must not collide with <tt>XN_FLAG_*</tt>.</p>
          
          <pre></pre>
          </div>
        
          <div class="decl" id="ASN1_STRFLGS_ESC_2253">
          
            <p><span class="first-word">ASN1_STRFLGS_ESC_2253</span> causes characters to be escaped as in <a href="https://www.rfc-editor.org/rfc/rfc2253.html">RFC 2253</a>, section 2.4.</p>
          
          <pre>#define ASN1_STRFLGS_ESC_2253 1</pre>
          </div>
        
          <div class="decl" id="ASN1_STRFLGS_ESC_CTRL">
          
            <p><span class="first-word">ASN1_STRFLGS_ESC_CTRL</span> causes all control characters to be escaped.</p>
          
          <pre>#define ASN1_STRFLGS_ESC_CTRL 2</pre>
          </div>
        
          <div class="decl" id="ASN1_STRFLGS_ESC_MSB">
          
            <p><span class="first-word">ASN1_STRFLGS_ESC_MSB</span> causes all characters above 127 to be escaped.</p>
          
          <pre>#define ASN1_STRFLGS_ESC_MSB 4</pre>
          </div>
        
          <div class="decl" id="ASN1_STRFLGS_ESC_QUOTE">
          
            <p><span class="first-word">ASN1_STRFLGS_ESC_QUOTE</span> causes the string to be surrounded by quotes, rather than using backslashes, when characters are escaped. Fewer characters will require escapes in this case.</p>
          
          <pre>#define ASN1_STRFLGS_ESC_QUOTE 8</pre>
          </div>
        
          <div class="decl" id="ASN1_STRFLGS_UTF8_CONVERT">
          
            <p><span class="first-word">ASN1_STRFLGS_UTF8_CONVERT</span> causes the string to be encoded as UTF-8, with each byte in the UTF-8 encoding treated as an individual character for purposes of escape sequences. If not set, each Unicode codepoint in the string is treated as a character, with wide characters escaped as &#34;\Uxxxx&#34; or &#34;\Wxxxxxxxx&#34;. Note this can be ambiguous if <tt>ASN1_STRFLGS_ESC_*</tt> are all unset. In that case, backslashes are not escaped, but wide characters are.</p>
          
          <pre>#define ASN1_STRFLGS_UTF8_CONVERT 0x10</pre>
          </div>
        
          <div class="decl" id="ASN1_STRFLGS_IGNORE_TYPE">
          
            <p><span class="first-word">ASN1_STRFLGS_IGNORE_TYPE</span> causes the string type to be ignored. The <tt>ASN1_STRING</tt> in-memory representation will be printed directly.</p>
          
          <pre>#define ASN1_STRFLGS_IGNORE_TYPE 0x20</pre>
          </div>
        
          <div class="decl" id="ASN1_STRFLGS_SHOW_TYPE">
          
            <p><span class="first-word">ASN1_STRFLGS_SHOW_TYPE</span> causes the string type to be included in the output.</p>
          
          <pre>#define ASN1_STRFLGS_SHOW_TYPE 0x40</pre>
          </div>
        
          <div class="decl" id="ASN1_STRFLGS_DUMP_ALL">
          
            <p><span class="first-word">ASN1_STRFLGS_DUMP_ALL</span> causes all strings to be printed as a hexdump, using <a href="https://www.rfc-editor.org/rfc/rfc2253.html">RFC 2253</a> hexstring notation, such as &#34;#0123456789ABCDEF&#34;.</p>
          
          <pre>#define ASN1_STRFLGS_DUMP_ALL 0x80</pre>
          </div>
        
          <div class="decl" id="ASN1_STRFLGS_DUMP_UNKNOWN">
          
            <p><span class="first-word">ASN1_STRFLGS_DUMP_UNKNOWN</span> behaves like <tt><a href="asn1.h.html#ASN1_STRFLGS_DUMP_ALL">ASN1_STRFLGS_DUMP_ALL</a></tt> but only applies to values of unknown type. If unset, unknown values will print their contents as single-byte characters with escape sequences.</p>
          
          <pre>#define ASN1_STRFLGS_DUMP_UNKNOWN 0x100</pre>
          </div>
        
          <div class="decl" id="ASN1_STRFLGS_DUMP_DER">
          
            <p><span class="first-word">ASN1_STRFLGS_DUMP_DER</span> causes hexdumped strings (as determined by <tt><a href="asn1.h.html#ASN1_STRFLGS_DUMP_ALL">ASN1_STRFLGS_DUMP_ALL</a></tt> or <tt><a href="asn1.h.html#ASN1_STRFLGS_DUMP_UNKNOWN">ASN1_STRFLGS_DUMP_UNKNOWN</a></tt>) to print the entire DER element as in <a href="https://www.rfc-editor.org/rfc/rfc2253.html">RFC 2253</a>, rather than only the contents of the <tt>ASN1_STRING</tt>.</p>
          
          <pre>#define ASN1_STRFLGS_DUMP_DER 0x200</pre>
          </div>
        
          <div class="decl" id="ASN1_STRFLGS_RFC2253">
          
            <p><span class="first-word">ASN1_STRFLGS_RFC2253</span> causes the string to be escaped as in <a href="https://www.rfc-editor.org/rfc/rfc2253.html">RFC 2253</a>, additionally escaping control characters.</p>
          
          <pre>#define ASN1_STRFLGS_RFC2253                                              \
  (ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB | \
   ASN1_STRFLGS_UTF8_CONVERT | ASN1_STRFLGS_DUMP_UNKNOWN |                \
   ASN1_STRFLGS_DUMP_DER)</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_print_ex">
          
            <p><span class="first-word">ASN1_STRING_print_ex</span> writes a human-readable representation of <tt>str</tt> to <tt>out</tt>. It returns the number of bytes written on success and -1 on error. If <tt>out</tt> is NULL, it returns the number of bytes it would have written, without writing anything.</p>
          
            <p>The <tt>flags</tt> should be a combination of combination of <tt>ASN1_STRFLGS_*</tt> constants. See the documentation for each flag for how it controls the output. If unsure, use <tt><a href="asn1.h.html#ASN1_STRFLGS_RFC2253">ASN1_STRFLGS_RFC2253</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_STRING_print_ex(BIO *out, const ASN1_STRING *str,
                                        unsigned long flags);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_print_ex_fp">
          
            <p><span class="first-word">ASN1_STRING_print_ex_fp</span> behaves like <tt><a href="asn1.h.html#ASN1_STRING_print_ex">ASN1_STRING_print_ex</a></tt> but writes to a <tt>FILE</tt> rather than a <tt>BIO</tt>.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_STRING_print_ex_fp(FILE *fp, const ASN1_STRING *str,
                                           unsigned long flags);</pre>
          </div>
        
          <div class="decl" id="i2a_ASN1_INTEGER">
          
            <p><span class="first-word">i2a_ASN1_INTEGER</span> writes a human-readable representation of <tt>a</tt> to <tt>bp</tt>. It returns the number of bytes written on success, or a negative number on error. On error, this function may have written a partial output to <tt>bp</tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2a_ASN1_INTEGER(BIO *bp, const ASN1_INTEGER *a);</pre>
          </div>
        
          <div class="decl" id="i2a_ASN1_ENUMERATED">
          
            <p><span class="first-word">i2a_ASN1_ENUMERATED</span> writes a human-readable representation of <tt>a</tt> to <tt>bp</tt>. It returns the number of bytes written on success, or a negative number on error. On error, this function may have written a partial output to <tt>bp</tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2a_ASN1_ENUMERATED(BIO *bp, const ASN1_ENUMERATED *a);</pre>
          </div>
        
          <div class="decl" id="i2a_ASN1_OBJECT">
          
            <p><span class="first-word">i2a_ASN1_OBJECT</span> writes a human-readable representation of <tt>a</tt> to <tt>bp</tt>. It returns the number of bytes written on success, or a negative number on error. On error, this function may have written a partial output to <tt>bp</tt>.</p>
          
          <pre>OPENSSL_EXPORT int i2a_ASN1_OBJECT(BIO *bp, const ASN1_OBJECT *a);</pre>
          </div>
        
          <div class="decl" id="i2a_ASN1_STRING">
          
            <p><span class="first-word">i2a_ASN1_STRING</span> writes a text representation of <tt>a</tt>&#39;s contents to <tt>bp</tt>. It returns the number of bytes written on success, or a negative number on error. On error, this function may have written a partial output to <tt>bp</tt>. <tt>type</tt> is ignored.</p>
          
            <p><span class="first-word">This</span> function does not decode <tt>a</tt> into a Unicode string. It only hex-encodes the internal representation of <tt>a</tt>. This is suitable for printing an OCTET STRING, but may not be human-readable for any other string type.</p>
          
          <pre>OPENSSL_EXPORT int i2a_ASN1_STRING(BIO *bp, const ASN1_STRING *a, int type);</pre>
          </div>
        
          <div class="decl" id="i2t_ASN1_OBJECT">
          
            <p><span class="first-word">i2t_ASN1_OBJECT</span> calls <tt><a href="obj.h.html#OBJ_obj2txt">OBJ_obj2txt</a></tt> with <tt>always_return_oid</tt> set to zero.</p>
          
          <pre>OPENSSL_EXPORT int i2t_ASN1_OBJECT(char *buf, int buf_len,
                                   const ASN1_OBJECT *a);</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="Low-level-encoding-functions">
        
          <div class="sectionpreamble">
          <p>Low-level encoding functions.</p>
          </div>
        

        
          <div class="decl" id="ASN1_get_object">
          
            <p><span class="first-word">ASN1_get_object</span> parses a BER element from up to <tt>max_len</tt> bytes at <tt>*inp</tt>. It returns <tt><a href="asn1.h.html#V_ASN1_CONSTRUCTED">V_ASN1_CONSTRUCTED</a></tt> if it successfully parsed a constructed element, zero if it successfully parsed a primitive element, and 0x80 on error. On success, it additionally advances <tt>*inp</tt> to the element body, sets <tt>*out_length</tt>, <tt>*out_tag</tt>, and <tt>*out_class</tt> to the element&#39;s length, tag number, and tag class, respectively,</p>
          
            <p><span class="first-word">Unlike</span> OpenSSL, this function does not support indefinite-length elements.</p>
          
            <p><span class="first-word">This</span> function is difficult to use correctly. Use <tt><a href="bytestring.h.html#CBS_get_asn1">CBS_get_asn1</a></tt> and related functions from bytestring.h.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> Remove support for non-minimal lengths.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_get_object(const unsigned char **inp, long *out_length,
                                   int *out_tag, int *out_class, long max_len);</pre>
          </div>
        
          <div class="decl" id="ASN1_put_object">
          
            <p><span class="first-word">ASN1_put_object</span> writes the header for a DER or BER element to <tt>*outp</tt> and advances <tt>*outp</tt> by the number of bytes written. The caller is responsible for ensuring <tt>*outp</tt> has enough space for the output. The header describes an element with length <tt>length</tt>, tag number <tt>tag</tt>, and class <tt>xclass</tt>. <tt>xclass</tt> should be one of the <tt>V_ASN1_*</tt> tag class constants. The element is primitive if <tt>constructed</tt> is zero and constructed if it is one or two. If <tt>constructed</tt> is two, <tt>length</tt> is ignored and the element uses indefinite-length encoding.</p>
          
            <p><span class="first-word">Use</span> <tt><a href="bytestring.h.html#CBB_add_asn1">CBB_add_asn1</a></tt> instead.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_put_object(unsigned char **outp, int constructed,
                                    int length, int tag, int xclass);</pre>
          </div>
        
          <div class="decl" id="ASN1_put_eoc">
          
            <p><span class="first-word">ASN1_put_eoc</span> writes two zero bytes to <tt>*outp</tt>, advances <tt>*outp</tt> to point past those bytes, and returns two.</p>
          
            <p><span class="first-word">Use</span> definite-length encoding instead.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_put_eoc(unsigned char **outp);</pre>
          </div>
        
          <div class="decl" id="ASN1_object_size">
          
            <p><span class="first-word">ASN1_object_size</span> returns the number of bytes needed to encode a DER or BER value with length <tt>length</tt> and tag number <tt>tag</tt>, or -1 on error. <tt>tag</tt> should not include the constructed bit or tag class. If <tt>constructed</tt> is zero or one, the result uses a definite-length encoding with minimally-encoded length, as in DER. If <tt>constructed</tt> is two, the result uses BER indefinite-length encoding.</p>
          
            <p><span class="first-word">Use</span> <tt><a href="bytestring.h.html#CBB_add_asn1">CBB_add_asn1</a></tt> instead.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_object_size(int constructed, int length, int tag);</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="Function-declaration-macros">
        
          <div class="sectionpreamble">
          <p>Function declaration macros.</p><p>The following macros declare functions for ASN.1 types. Prefer writing the prototypes directly. Particularly when <tt>type</tt>, <tt>itname</tt>, or <tt>name</tt> differ, the macros can be difficult to understand.</p>
          </div>
        

        
          <div class="decl" id="DECLARE_ASN1_FUNCTIONS">
          
          <pre>#define DECLARE_ASN1_FUNCTIONS(type) DECLARE_ASN1_FUNCTIONS_name(type, type)</pre>
          </div>
        
          <div class="decl" id="DECLARE_ASN1_ALLOC_FUNCTIONS">
          
          <pre>#define DECLARE_ASN1_ALLOC_FUNCTIONS(type) \
  DECLARE_ASN1_ALLOC_FUNCTIONS_name(type, type)</pre>
          </div>
        
          <div class="decl" id="DECLARE_ASN1_FUNCTIONS_name">
          
          <pre>#define DECLARE_ASN1_FUNCTIONS_name(type, name) \
  DECLARE_ASN1_ALLOC_FUNCTIONS_name(type, name) \
  DECLARE_ASN1_ENCODE_FUNCTIONS(type, name, name)</pre>
          </div>
        
          <div class="decl" id="DECLARE_ASN1_FUNCTIONS_fname">
          
          <pre>#define DECLARE_ASN1_FUNCTIONS_fname(type, itname, name) \
  DECLARE_ASN1_ALLOC_FUNCTIONS_name(type, name)          \
  DECLARE_ASN1_ENCODE_FUNCTIONS(type, itname, name)</pre>
          </div>
        
          <div class="decl" id="DECLARE_ASN1_ENCODE_FUNCTIONS">
          
          <pre>#define DECLARE_ASN1_ENCODE_FUNCTIONS(type, itname, name)             \
  OPENSSL_EXPORT type *d2i_##name(type **a, const unsigned char **in, \
                                  long len);                          \
  OPENSSL_EXPORT int i2d_##name(type *a, unsigned char **out);        \
  DECLARE_ASN1_ITEM(itname)</pre>
          </div>
        
          <div class="decl" id="DECLARE_ASN1_ENCODE_FUNCTIONS_const">
          
          <pre>#define DECLARE_ASN1_ENCODE_FUNCTIONS_const(type, name)               \
  OPENSSL_EXPORT type *d2i_##name(type **a, const unsigned char **in, \
                                  long len);                          \
  OPENSSL_EXPORT int i2d_##name(const type *a, unsigned char **out);  \
  DECLARE_ASN1_ITEM(name)</pre>
          </div>
        
          <div class="decl" id="DECLARE_ASN1_FUNCTIONS_const">
          
          <pre>#define DECLARE_ASN1_FUNCTIONS_const(name) \
  DECLARE_ASN1_ALLOC_FUNCTIONS(name)       \
  DECLARE_ASN1_ENCODE_FUNCTIONS_const(name, name)</pre>
          </div>
        
          <div class="decl" id="DECLARE_ASN1_ALLOC_FUNCTIONS_name">
          
          <pre>#define DECLARE_ASN1_ALLOC_FUNCTIONS_name(type, name) \
  OPENSSL_EXPORT type *name##_new(void);              \
  OPENSSL_EXPORT void name##_free(type *a);</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="Deprecated-functions">
        
          <div class="sectionpreamble">
          <p>Deprecated functions.</p>
          </div>
        

        
          <div class="decl" id="M_ASN1_STRING_length">
          
            <p><span class="first-word">M_ASN1_*</span> are legacy aliases for various <tt>ASN1_STRING</tt> functions. Use the functions themselves.</p>
          
          <pre>#define M_ASN1_STRING_length(x) ASN1_STRING_length(x)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_STRING_type">
          
          <pre>#define M_ASN1_STRING_type(x) ASN1_STRING_type(x)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_STRING_data">
          
          <pre>#define M_ASN1_STRING_data(x) ASN1_STRING_data(x)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_BIT_STRING_new">
          
          <pre>#define M_ASN1_BIT_STRING_new() ASN1_BIT_STRING_new()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_BIT_STRING_free">
          
          <pre>#define M_ASN1_BIT_STRING_free(a) ASN1_BIT_STRING_free(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_BIT_STRING_dup">
          
          <pre>#define M_ASN1_BIT_STRING_dup(a) ASN1_STRING_dup(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_BIT_STRING_cmp">
          
          <pre>#define M_ASN1_BIT_STRING_cmp(a, b) ASN1_STRING_cmp(a, b)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_BIT_STRING_set">
          
          <pre>#define M_ASN1_BIT_STRING_set(a, b, c) ASN1_BIT_STRING_set(a, b, c)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_INTEGER_new">
          
          <pre>#define M_ASN1_INTEGER_new() ASN1_INTEGER_new()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_INTEGER_free">
          
          <pre>#define M_ASN1_INTEGER_free(a) ASN1_INTEGER_free(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_INTEGER_dup">
          
          <pre>#define M_ASN1_INTEGER_dup(a) ASN1_INTEGER_dup(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_INTEGER_cmp">
          
          <pre>#define M_ASN1_INTEGER_cmp(a, b) ASN1_INTEGER_cmp(a, b)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_ENUMERATED_new">
          
          <pre>#define M_ASN1_ENUMERATED_new() ASN1_ENUMERATED_new()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_ENUMERATED_free">
          
          <pre>#define M_ASN1_ENUMERATED_free(a) ASN1_ENUMERATED_free(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_ENUMERATED_dup">
          
          <pre>#define M_ASN1_ENUMERATED_dup(a) ASN1_STRING_dup(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_ENUMERATED_cmp">
          
          <pre>#define M_ASN1_ENUMERATED_cmp(a, b) ASN1_STRING_cmp(a, b)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_OCTET_STRING_new">
          
          <pre>#define M_ASN1_OCTET_STRING_new() ASN1_OCTET_STRING_new()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_OCTET_STRING_free">
          
          <pre>#define M_ASN1_OCTET_STRING_free(a) ASN1_OCTET_STRING_free()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_OCTET_STRING_dup">
          
          <pre>#define M_ASN1_OCTET_STRING_dup(a) ASN1_OCTET_STRING_dup(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_OCTET_STRING_cmp">
          
          <pre>#define M_ASN1_OCTET_STRING_cmp(a, b) ASN1_OCTET_STRING_cmp(a, b)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_OCTET_STRING_set">
          
          <pre>#define M_ASN1_OCTET_STRING_set(a, b, c) ASN1_OCTET_STRING_set(a, b, c)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_OCTET_STRING_print">
          
          <pre>#define M_ASN1_OCTET_STRING_print(a, b) ASN1_STRING_print(a, b)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_PRINTABLESTRING_new">
          
          <pre>#define M_ASN1_PRINTABLESTRING_new() ASN1_PRINTABLESTRING_new()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_PRINTABLESTRING_free">
          
          <pre>#define M_ASN1_PRINTABLESTRING_free(a) ASN1_PRINTABLESTRING_free(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_IA5STRING_new">
          
          <pre>#define M_ASN1_IA5STRING_new() ASN1_IA5STRING_new()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_IA5STRING_free">
          
          <pre>#define M_ASN1_IA5STRING_free(a) ASN1_IA5STRING_free(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_IA5STRING_dup">
          
          <pre>#define M_ASN1_IA5STRING_dup(a) ASN1_STRING_dup(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_UTCTIME_new">
          
          <pre>#define M_ASN1_UTCTIME_new() ASN1_UTCTIME_new()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_UTCTIME_free">
          
          <pre>#define M_ASN1_UTCTIME_free(a) ASN1_UTCTIME_free(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_UTCTIME_dup">
          
          <pre>#define M_ASN1_UTCTIME_dup(a) ASN1_STRING_dup(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_T61STRING_new">
          
          <pre>#define M_ASN1_T61STRING_new() ASN1_T61STRING_new()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_T61STRING_free">
          
          <pre>#define M_ASN1_T61STRING_free(a) ASN1_T61STRING_free(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_GENERALIZEDTIME_new">
          
          <pre>#define M_ASN1_GENERALIZEDTIME_new() ASN1_GENERALIZEDTIME_new()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_GENERALIZEDTIME_free">
          
          <pre>#define M_ASN1_GENERALIZEDTIME_free(a) ASN1_GENERALIZEDTIME_free(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_GENERALIZEDTIME_dup">
          
          <pre>#define M_ASN1_GENERALIZEDTIME_dup(a) ASN1_STRING_dup(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_GENERALSTRING_new">
          
          <pre>#define M_ASN1_GENERALSTRING_new() ASN1_GENERALSTRING_new()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_GENERALSTRING_free">
          
          <pre>#define M_ASN1_GENERALSTRING_free(a) ASN1_GENERALSTRING_free(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_UNIVERSALSTRING_new">
          
          <pre>#define M_ASN1_UNIVERSALSTRING_new() ASN1_UNIVERSALSTRING_new()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_UNIVERSALSTRING_free">
          
          <pre>#define M_ASN1_UNIVERSALSTRING_free(a) ASN1_UNIVERSALSTRING_free(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_BMPSTRING_new">
          
          <pre>#define M_ASN1_BMPSTRING_new() ASN1_BMPSTRING_new()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_BMPSTRING_free">
          
          <pre>#define M_ASN1_BMPSTRING_free(a) ASN1_BMPSTRING_free(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_VISIBLESTRING_new">
          
          <pre>#define M_ASN1_VISIBLESTRING_new() ASN1_VISIBLESTRING_new()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_VISIBLESTRING_free">
          
          <pre>#define M_ASN1_VISIBLESTRING_free(a) ASN1_VISIBLESTRING_free(a)</pre>
          </div>
        
          <div class="decl" id="M_ASN1_UTF8STRING_new">
          
          <pre>#define M_ASN1_UTF8STRING_new() ASN1_UTF8STRING_new()</pre>
          </div>
        
          <div class="decl" id="M_ASN1_UTF8STRING_free">
          
          <pre>#define M_ASN1_UTF8STRING_free(a) ASN1_UTF8STRING_free(a)</pre>
          </div>
        
          <div class="decl" id="B_ASN1_PRINTABLE">
          
            <p><span class="first-word">B_ASN1_PRINTABLE</span> is a bitmask for an ad-hoc subset of string-like types. Note the presence of <tt><a href="asn1.h.html#B_ASN1_UNKNOWN">B_ASN1_UNKNOWN</a></tt> means it includes types which <tt><a href="asn1.h.html#ASN1_tag2bit">ASN1_tag2bit</a></tt> maps to <tt><a href="asn1.h.html#B_ASN1_UNKNOWN">B_ASN1_UNKNOWN</a></tt>.</p>
          
            <p><span class="first-word">Do</span> not use this. Despite the name, it has no connection to PrintableString or printable characters. See https://crbug.com/boringssl/412.</p>
          
          <pre>#define B_ASN1_PRINTABLE                                              \
  (B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING | \
   B_ASN1_IA5STRING | B_ASN1_BIT_STRING | B_ASN1_UNIVERSALSTRING |    \
   B_ASN1_BMPSTRING | B_ASN1_UTF8STRING | B_ASN1_SEQUENCE | B_ASN1_UNKNOWN)</pre>
          </div>
        
          <div class="decl" id="ASN1_PRINTABLE_new">
          
            <p><span class="first-word">ASN1_PRINTABLE_new</span> returns a newly-allocated <tt>ASN1_STRING</tt> with type -1, or NULL on error. The resulting <tt>ASN1_STRING</tt> is not a valid ASN.1 value until initialized with a value.</p>
          
          <pre>OPENSSL_EXPORT ASN1_STRING *ASN1_PRINTABLE_new(void);</pre>
          </div>
        
          <div class="decl" id="ASN1_PRINTABLE_free">
          
            <p><span class="first-word">ASN1_PRINTABLE_free</span> calls <tt><a href="asn1.h.html#ASN1_STRING_free">ASN1_STRING_free</a></tt>.</p>
          
          <pre>OPENSSL_EXPORT void ASN1_PRINTABLE_free(ASN1_STRING *str);</pre>
          </div>
        
          <div class="decl" id="d2i_ASN1_PRINTABLE">
          
            <p><span class="first-word">d2i_ASN1_PRINTABLE</span> parses up to <tt>len</tt> bytes from <tt>*inp</tt> as a DER-encoded CHOICE of an ad-hoc subset of string-like types, as described in <tt><a href="asn1.h.html#d2i_SAMPLE_with_reuse">d2i_SAMPLE_with_reuse</a></tt>.</p>
          
            <p><span class="first-word">Do</span> not use this. Despite, the name it has no connection to PrintableString or printable characters. See https://crbug.com/boringssl/412.</p>
          
            <p><span class="first-word">TODO(https://crbug.com/boringssl/354):</span> This function currently also accepts BER, but this will be removed in the future.</p>
          
          <pre>OPENSSL_EXPORT ASN1_STRING *d2i_ASN1_PRINTABLE(ASN1_STRING **out,
                                               const uint8_t **inp, long len);</pre>
          </div>
        
          <div class="decl" id="i2d_ASN1_PRINTABLE">
          
            <p><span class="first-word">i2d_ASN1_PRINTABLE</span> marshals <tt>in</tt> as DER, as described in <tt><a href="asn1.h.html#i2d_SAMPLE">i2d_SAMPLE</a></tt>.</p>
          
            <p><span class="first-word">Do</span> not use this. Despite the name, it has no connection to PrintableString or printable characters. See https://crbug.com/boringssl/412.</p>
          
          <pre>OPENSSL_EXPORT int i2d_ASN1_PRINTABLE(const ASN1_STRING *in, uint8_t **outp);</pre>
          </div>
        
          <div class="decl" >
          
            <p><span class="first-word">ASN1_PRINTABLE</span> is an <tt>ASN1_ITEM</tt> whose ASN.1 type is a CHOICE of an ad-hoc subset of string-like types, and whose C type is <tt>ASN1_STRING*</tt>.</p>
          
            <p><span class="first-word">Do</span> not use this. Despite the name, it has no connection to PrintableString or printable characters. See https://crbug.com/boringssl/412.</p>
          
          <pre>DECLARE_ASN1_ITEM(ASN1_PRINTABLE)</pre>
          </div>
        
          <div class="decl" id="ASN1_INTEGER_set">
          
            <p><span class="first-word">ASN1_INTEGER_set</span> sets <tt>a</tt> to an INTEGER with value <tt>v</tt>. It returns one on success and zero on error.</p>
          
            <p><span class="first-word">Use</span> <tt><a href="asn1.h.html#ASN1_INTEGER_set_uint64">ASN1_INTEGER_set_uint64</a></tt> and <tt><a href="asn1.h.html#ASN1_INTEGER_set_int64">ASN1_INTEGER_set_int64</a></tt> instead.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_INTEGER_set(ASN1_INTEGER *a, long v);</pre>
          </div>
        
          <div class="decl" id="ASN1_ENUMERATED_set">
          
            <p><span class="first-word">ASN1_ENUMERATED_set</span> sets <tt>a</tt> to an ENUMERATED with value <tt>v</tt>. It returns one on success and zero on error.</p>
          
            <p><span class="first-word">Use</span> <tt><a href="asn1.h.html#ASN1_ENUMERATED_set_uint64">ASN1_ENUMERATED_set_uint64</a></tt> and <tt><a href="asn1.h.html#ASN1_ENUMERATED_set_int64">ASN1_ENUMERATED_set_int64</a></tt> instead.</p>
          
          <pre>OPENSSL_EXPORT int ASN1_ENUMERATED_set(ASN1_ENUMERATED *a, long v);</pre>
          </div>
        
          <div class="decl" id="ASN1_INTEGER_get">
          
            <p><span class="first-word">ASN1_INTEGER_get</span> returns the value of <tt>a</tt> as a <tt>long</tt>, or -1 if <tt>a</tt> is out of range or the wrong type.</p>
          
            <p><span class="first-word">WARNING:</span> This function&#39;s return value cannot distinguish errors from -1. Use <tt><a href="asn1.h.html#ASN1_INTEGER_get_uint64">ASN1_INTEGER_get_uint64</a></tt> and <tt><a href="asn1.h.html#ASN1_INTEGER_get_int64">ASN1_INTEGER_get_int64</a></tt> instead.</p>
          
          <pre>OPENSSL_EXPORT long ASN1_INTEGER_get(const ASN1_INTEGER *a);</pre>
          </div>
        
          <div class="decl" id="ASN1_ENUMERATED_get">
          
            <p><span class="first-word">ASN1_ENUMERATED_get</span> returns the value of <tt>a</tt> as a <tt>long</tt>, or -1 if <tt>a</tt> is out of range or the wrong type.</p>
          
            <p><span class="first-word">WARNING:</span> This function&#39;s return value cannot distinguish errors from -1. Use <tt><a href="asn1.h.html#ASN1_ENUMERATED_get_uint64">ASN1_ENUMERATED_get_uint64</a></tt> and <tt><a href="asn1.h.html#ASN1_ENUMERATED_get_int64">ASN1_ENUMERATED_get_int64</a></tt> instead.</p>
          
          <pre>OPENSSL_EXPORT long ASN1_ENUMERATED_get(const ASN1_ENUMERATED *a);</pre>
          </div>
        
        </div>
      
    
      
        <div class="section" id="General-No-op-Functions-[Deprecated]">
        
          <div class="sectionpreamble">
          <p>General No-op Functions [Deprecated].</p>
          </div>
        

        
          <div class="decl" id="ASN1_STRING_set_default_mask">
          
            <p><span class="first-word">ASN1_STRING_set_default_mask</span> does nothing.</p>
          
          <pre>OPENSSL_EXPORT OPENSSL_DEPRECATED void ASN1_STRING_set_default_mask(
    unsigned long mask);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_set_default_mask_asc">
          
            <p><span class="first-word">ASN1_STRING_set_default_mask_asc</span> returns one.</p>
          
          <pre>OPENSSL_EXPORT OPENSSL_DEPRECATED int ASN1_STRING_set_default_mask_asc(
    const char *p);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_get_default_mask">
          
            <p><span class="first-word">ASN1_STRING_get_default_mask</span> returns <tt><a href="asn1.h.html#B_ASN1_UTF8STRING">B_ASN1_UTF8STRING</a></tt>. This is the value AWS-LC uses by default and is not configurable.</p>
          
          <pre>OPENSSL_EXPORT OPENSSL_DEPRECATED unsigned long ASN1_STRING_get_default_mask(
    void);</pre>
          </div>
        
          <div class="decl" id="ASN1_STRING_TABLE_cleanup">
          
            <p><span class="first-word">ASN1_STRING_TABLE_cleanup</span> does nothing.</p>
          
          <pre>OPENSSL_EXPORT OPENSSL_DEPRECATED void ASN1_STRING_TABLE_cleanup(void);</pre>
          </div>
        
        </div>
      
    
    </div>
  </body>
</html>